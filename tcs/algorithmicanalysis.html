<!DOCTYPE html>
<html>

<head>
  <!-- Get Style Sheets and JS from Bootstrap -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
  <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>

	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

  <!-- For math formulas -->
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
	</script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

	<link rel="stylesheet" href="/style.css">

  <meta name="viewport" content="width=device-width, initial-scale=1">

	<title>Algorithmic Analysis - Theoretical Computer Science</title>
</head>

<body>
	<script src="/script.js"></script>

	<!--Navigation bar-->
	<div class="nav-placeholder" id="nav-placeholder"></div>
	<!--end of Navigation bar-->

	<div class="information">
		<h1>Algorithmic Analysis</h1>
		<h4>From Intro To College Level Crash Course</h4>
    <span class="dot"></span><p><i>Still Adding To This</i></p>

    <br>
    <br>

    <hr>

    <h5>Table of Contents</h5>
    <ol class="table-of-contents">
      <li><a href="#rundown">Rundown</a></li>
      <ul>
          <li><a href="#how-to-read">Structure of this Page</a></li>
          <li><a href="#def-algorithmic-analysis">What is Algorithmic Anaylsis Anyways</a></li>
      </ul>
      <li><a href="#complexity-theory">Complexity Theory</a></li>
      <ul>
          <li><a href="#best-case-time-complexity">Best-Case Time Complexity - \(\Omega\)</a></li>
          <ul>
                  <li><a href="#best-case-equation">Best-Case Time Complexity Equation</a></li>
          </ul>
          <li>Worst-Case Time Complexity - \(O\)</li>
          <li>Average-Case Time Complexity - \(\Theta\)</li>
      </ul>
      <li>Key Properties of Asymptotic Operations</li>
      <ul>
          <li>Reflextivity</li>
          <li>Constants</li>
          <li>Transitivity</li>
          <li>Products</li>
          <li>Sum of Functions</li>
      </ul>
      <li>Run Time Analysis</li>
      <li>Proofs</li>
      <ul>
          <li>Masters Theorm</li>
          <li>Recursion Tree</li>
					<li>Proof by Induction</li>
      </ul>
    </ol>
    <hr>

    <div class="rundown" id="rundown">
      <p class="category-header">Rundown</p>
      <p class="section-header" id="how-to-read">Structure of this Page</p>
      <p class="how-to-read">This page is broken into mutiple sections. The sections are given in the contents above. There are subsections of those sections. Understanding the depth of analysis of each section can be determined by the following "algorithm":
        
        (A) Beggining of Section &lt;- Intro
        (B) Subsection of A &lt;- Continuation of A so more in depth
        (C) Subsection of B &lt;- Continuation of B so more in depth
        ... 
        (A\(_{n}\)) Subsection of A\(_{n-1}\) &lt;- Continuation of A\(_{n-1}\) and most in depth
      </p>
      <p class="section-header" id="def-algorithmic-analysis">What is Algorithmic Anaylsis Anyways</p>
      <p>Algorithmic analysis can be defined as the process of figuring out the computational complexity of algorithms with respect to time, storage, or other resources that are required to execute the algorithm.</p>
    </div>

    <div class="complexity-theory" id="complexity-theory">
      <p class="category-header">Complexity Theory</p>
			<p>As previously stated, complexity theory deals with coming to understand the resources required by an algoirthm. Resources being time, storage, and other resources. For now we will first take a look at how to figure out the time resource requirment of an algorithm.</p>
      <p>For time, we are refering to how long the program would theoretically take from the moment its given the input to the moment it finished its task. Since its theoretical, we do not apply numbers to this, but rather symbols. We will look at this later. Now, this task could be sorting a list of numbers, or finding the shortest path from point A to point B through a series of streets, or creating a job schedule. For any of these tasks and their repsective algorithms, if you think about it, how the algorithm is made, its design and thus affects its time complexity. If we have a bad algorithm desgin, then we have an algorithm that is going to take longer to finish running than if we had a well made algorithm.</p>
      <p class="section-header">Input Size Affect on Time Complexity</p>
      <p>Now you may be thinking, "Well doesn't other factors effect how long an algorithm will run for"? The answer is yes, and greater computer scientist have thought of this too. But before we jump down that rabbit whole, lets take a loot at some things that would more obviously affect an algorithms run time: input size.</p>
      <p>To take an intuitive approach: greater the size of the input the greater the time to run the algorithm, right? Lets take a look at two of our earlier algorithms as examples. For the algorithm that finds the shortest distance from point A to point B through a series of streets, lets say that there is only 1 street. Then it would be quite fast for an algorithm to find the shortest path since there is only one path or on input. Now lets say that you are trying to find the shortest path from the California to New York. Every street the algroithm looks at, it has to look at another 3, 4, or more streets that connect to that one street. Then when it choses the first street, now it must look at another 3, 4, or 5. But wait, it still has to go back and check the other streets from where it was originally because any combination of streets could be the shortest path. Now lets  very briefly look at a arbitrary sorting algorithm. It would take a lot longer to sort 3 numbers than say 10,000,000. We can see that input size greatly effects the time it takes to run an algroithm.</p>
      <p>This idea that sizes affect how long a algorithm runs is clear and for the most part intuitive. However, often, when figuring out the <i>general</i> time complxity for an algorithm, the actual number that represents the size is left out. The reason being is because we want to know the general time it takes for an algorithm to run regardless of the actual number for input size. One of the reasons we do this is because we want to compare algorithms. So when comparing algorithms, we need things to be on a level playing field to begin with. It is much eaiser to compare algorithms with all variables being equal then comparing algorithms running on different processors, different storage systems, different input sizes, etc. We need them standing back to back on level ground. We can't have one on a i9 9900k stepping stool.</p>
      <p class="section-header">Intro to Best, Average, Worst Case Complexity</p>
      <p>For this next part, we need to understand that figuring out how long an algorithm runs for is not one dimensional. Meaning, we want to know if lets say, "If I deploy this algorithm for my app, what is the fastest it can possibly run, the slowest it can possibly run, and the average it can possibly run:? These are all important factors to consider when comparing then chosing which algorithm to implement in your app, website, robot, etc. What you might realize is that one of these possible run times for the algorithm is more important that the other. That being the slowest time, or worst-case-time complexity.</p>
      <p>Now, when I first learned this fact, I must admit I did not know what my professor was talking about. To me, the average time, or average-case-time complexity should be more important. My thought process being that if I deploy and app with my an algorithm, I want to know what will on average can I expect my users see. However, it is important to realize</p>
      <div class="best-case-time-complexity" id="best-case-time-complexity">
        <p class="section-header">Best Case Time Complexity - \(\Omega\)</p>
				<p>We will take a look at a well know sorting algorithm in order to get out feet wet. This algorithm is insertion sort. Insertion sort can be defined by the following psudeo-code.</p>
<p class="code">
pseudocode: Insertion Sort Algorithm

function Insertion Sort(List L)
	i = 0
	<b>while</b> i &lt; length(L)
		j = i 
		<b>while</b> j &gt; i <b>and</b> L[j-1] &gt; L[j]
			<b>swap</b> L[j] and L[j-1]  
			j = j - 1
		<b>end while</b>
		i = i + 1
	<b>end while</b>   
</p> 
				<p>If this pseudo-code doesn't make all that much sense, that is fine of course. However, in order to continue with the rest of this it is best you understand it. <a href="https://www.tutorialspoint.com/data_structures_algorithms/insertion_sort_algorithm.htm"> Here is a quality website's explanation and in depth look at insertion sort</a></p>
				<p>Insertion sort is a great introduction algorithm to look at and understand the effect the type of input has on the time complexity of the algorithm. First, think what would happen if all the data in the input, or the type of input, was already sorted in <i>ascending</i> order. Emphasis on ascending. Although unrealistic, it is a good to see its effects. Well, based on the way insertion sort operates, the algorithm would not have to make any changes. Really, it could traverse through the whole list in one loop. Meaning the code in the main loop would only have to <i>execute</i> once for every item in the list, or the size of the list. The size of the list is denoted as \(n\).</p>
        <p> This is called a <i>best-case time complexity</i>. Why, well because best-case time complexity can be summarized by saying the minimum number of steps an algorithm needs to take on any instance of size n. This will be the least amount of steps an algorithm could theoretically operate in. In essence, it is a lower bounds. This is best-case time complexity is denoted with \(\Omega\), a.k.a. Big-Omega.</p>

				<p>Now, we need to look at this idea of lower bounds. In essesence, a lower bound describes an element of some function for which is is less than or equal to every element of that function. Basically, a limit for which nothing can pass. Upper bound, meaning nothing can go higher than y1, and lower bound meaning nothing can go lower than y2.</p>

				<p>Just like there exists a lower bounds, our best-case time complexity, there also exists an upper-bound, and a tight-bound. All of which will be discussed in the later sections.</p>

				<!-- Here is a graph of what we will discuss taken from <a href="https://www.hackerearth.com/practice/basic-programming/complexity-analysis/time-and-space-complexity/tutorial/">hackerearth</a>.</p>
				<img src="/images/complexity-bounds-graphs.jpg" alt="Complexity Graph"> -->

        <div class="best-case-equation" id="best-case-equation">
          <p class="subsection-header">Best-Case Time Complexity Equation</p>
        
          <p>Mathematically the best-case time complexity can be described by the following equation:</p>

          <h5 class="math-notation">$$\Omega(g(n)) = \exists \, c > 0, n_{0} > 0$$</h5>
          <h5 class="math-notation">$$s.t. \; 0 \leq cg(n) \leq f(n)$$</h5>
          <h5 class="math-notation">$$\forall \, n \geq n _{0}$$</h5>

          <p>
            Lets break this down just in case you're not too familiar with the notation. I will break this down into individual parts, then piece them together to arrive at the final equation. First, lets start with what's left of the equal sign.
          </p>

          <h5 class="math-notation">$$\Omega(g(n))$$</h5>

          <p>
            \(\Omega\) is Big-Omega which denotes best-case time complexity or the lower-bounds for a function \(g(n)\). \(g\) is a function that takes the input \(n\), a.k.a. the input size. Next, lets look atL
          </p>

          <h5 class="math-notation">$$\exists \, c > 0, n_{0} > 0$$</h5>

          <p>
            The \(\exists \) denotes, "there exists". So the equation states that there exists two constants, \(c\) and \(n_{0}\) whose values both are greater than 0. Using this equation more in context, we can say that \(c\) accounts for things like runtime constants such as processor speed, memory speed, etc..
          </p>

          <h5 class="math-notation">$$0 \leq cg(n) \leq f(n)$$</h5>

          <p>
<<<<<<< HEAD
            \(0 \leq cg(n) \leq f(n)\) states that our lower bounds, \(g(n)\) times some constant \(c\) lies between \(0\) and our original function \(f(n)\). This makes sense as the lower-bound runtime for our algorithm cannot be less than 0 but also needs to be lower than or equal to the runtime of our original function. Otherwise it would not be much of a lower bound.
=======
            Then there is \(0 \leq cg(n) \leq f(n)\). This means that \(cg(n)\) lies between \(0\) and \(f(n)\). In this instance, \(f(n)\) is the original asymptotic function, the one that is derived from the algorithm itself. \(cg(n)\) denotes the lower-bounds of our original asymptotic function times some constant \(c\). Thus, this is saying that the lower-bounds of the original asymptotic function for our algorithm lies at or below the original asymptotic function or at or above \(0\).
>>>>>>> origin/master
          </p>

          <h5 class="math-notation">$$\exists \, c > 0, n_{0} > 0$$</h5>
          <h5 class="math-notation">$$s.t. \; 0 \leq cg(n) \leq f(n)$$</h5>

          <p>
            Now, to put the last two parts together. This segment of the equation is saying that the lower-bounds of our original function \(g(n)\) times some constant \(c\), that is great than 0, lies at or below the original function \(f(n)\) or at or above \(0\).
          </p>

          <p>TODO::END</p>
          
          <p>
            So putting it all together and we have the equation: 
          </p>
          <h5 class="math-notation">$$\Omega(g(n)) = \exists \, c > 0, n_{0} > 0$$</h5>
          <h5 class="math-notation">$$s.t. \; 0 \leq cg(n) \leq f(n)$$</h5>
          <h5 class="math-notation">$$\forall \, n \geq n _{0}$$</h5>
          <p>
            From what we have learned we can say that this equation here says that there exists a constant \(c\) and \(n\), \(c\) being runtime constants, that are greater than 0 such that our lower-bound exists between 0 and the original asymptotic function.
          </p>

					
          <!-- go on to explain and pieace together the rest of the equation. Also make sure this whole thing builds off eachother. Meaning, explain what asymptotic means, because the word is used later. And it would not make much sense to have an intro to teach newer people but then expect them to know what asymptotic means. So make sure it builds off eachother. This is going to be a long page, like a CRASH COURSE so yeah. -->
        </div>

				<div class="best-case-graph" id="best-case-graph">
          <p class="subsection-header">Best-Case Time Complexity Graph</p>
					<img src="/images/lower-bounds-graph.JPG" alt="Lower Bounds Graph" class="figure">
				</div>
      </div>
      <div class="worst-case-time-complexity" id="worst-case-time-complexity">
        <p class="section-header">Worst Case Time Complexity - \(O\)</p>
        <p>
          So we know that best case time-complexity is when an algorithm runs is the least amount of time it could theoretically operate in. So, it follows that the worst case time-complexity is the worst time an algorith could theoretically operate in. Now, what is an example of this. Lets take our previous example of insertion sort. Now, recall, that the <i>type</i> of input for the algorithm can affect its time complexity. So, I want you to take a moment to come up with an example.
        </p>
        <p>
          Lets continue. An example for which the time complexity is worse is when all of the input data is sorted in descending order.
        </p>
      </div>    
    </div>
	</div>

  <div class="collapsible-contents-button">
    <div class="panel-group">
      <div class="panel panel-default">
        <div class="panel-collapse collapse" id="collapse">
          <ul>
            <li><a href="#nav-placeholder">Top of the Page</a></li>
          </ul>
          <ol>
            <li><a href="#rundown">Rundown</a></li>
            <ul>
                <li><a href="#how-to-read">Structure of this Page</a></li>
                <li><a href="#def-algorithmic-analysis">What is Algorithmic Anaylsis Anyways</a></li>
            </ul>
            <li><a href="#complexity-theory">Complexity Theory</a></li>
            <ul>
                <li><a href="#best-case-time-complexity">Best-Case Time Complexity - \(\Omega\)</a></li>
                <ul>
                        <li><a href="#best-case-equation">Best-Case Time Complexity Equation</a></li>
                </ul>
                <li>Worst-Case Time Complexity - \(O\)</li>
                <li>Average-Case Time Complexity - \(\Theta\)</li>
            </ul>
            <li>Key Properties of Asymptotic Operations</li>
            <ul>
                <li>Reflextivity</li>
                <li>Constants</li>
                <li>Transitivity</li>
                <li>Products</li>
                <li>Sum of Functions</li>
            </ul>
            <li>Run Time Analysis</li>
            <li>Proofs</li>
            <ul>
                <li>Proof By Contradiction</li>
                <li>Limits Relationship Proof</li>
            </ul>
          </ol>
          <ul>
            <li><a href="#footer-placeholder">Bottom of the Page</a></li>
          </ul>
        </div>
        <button class="btn btn-primary contents-button" type="button" data-toggle="collapse" data-target="#collapse" aria-expanded="false" aria-controls="collapseExample" id="algorithmic-analysis-contents-button">
          <i class="far fa-list-alt" id="table-of-contents-icon"></i>
        </button>
      </div>
    </div>
  </div>

  <!-- <a href="#nav-placeholder" id="fixed-to-top-button"><button type="button" class="btn btn-primary">Top of the Page</button></a> -->

  <!-- <a href="#nav-placeholder" id="fixed-to-top-button">Top of the Page</a> -->

  <!--Footer bar-->
  <div class="footer-placeholder" id="footer-placeholder"></div>
  <!--end of Footer bar-->
</body>

</html>