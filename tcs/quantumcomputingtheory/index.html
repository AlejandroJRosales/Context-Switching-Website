<!DOCTYPE html>
<html>

<head>
	<!-- Style sheet for Bootstrap -->
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
		integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous" />

	<!-- Style sheets for "font awesome" icons -->
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.13.0/css/all.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

	<link rel="stylesheet" href="/assets/css/style.css">

	<meta name="viewport" content="width=device-width, initial-scale=1">

	<title>Quantum Computing Theory - Context Switching</title>
</head>

<body>
	<div class="nav-placeholder" id="nav-placeholder"></div>
	<div class="title-section"></div>

	<div class="information">

		<div class="table-of-contents"></div>

		<div class="category-header-div">
			<p class="category-header" id="quantum-computing-theory">Quantum Computing Theory</p>

			<!-- <p>
				<b style="color:red;">Warning:</b> The field of quantum computing is an emerging, relatively new field. So,
				there
				are many components continously being
				updated as theoretical computer scientists understanding of quantum mechanics and quatum computing evolves.
			</p> -->

			<div class="section-header-div">
				<p class="section-header" id="introduction">Introduction</p>

				<p>
					Quantum Computing Theory is a field of computer science that uses the principles of quantum
					mechanics,
					mathematics, and computer science. By borrowing concepts from each field scientists can rigorously
					define both
					a broad and narrow theoretical model of a quantum computer, and later apply it to the real world.
					These
					theoretical models, such as the result of a quantum system manipulating subatomic particles, the
					theoretical
					circuits quantum computers implement to perform larger operations, and how to optimize the resource
					complexity
					for quantum systems, are just a few of the fundamental concepts in quantum computing theory.
				</p>

				<div class="subsection-header-div">
					<p class="subsection-header" id="1-qubit">1-Qubit</p>
					<div class="subsubection-header-div">
						<p class="subsubsection-header" id="qubit">Qubit</p>
						A qubit, short for quantum bit, is a two-level quantum system and is a part of
						two-dimensional Hilbert space \(H_{2}\), where Hilbert space \(H\)
						is nondenumerable infinite complex vector space. The two-dimensional complex vector space
						\(H_{2}\)
						comes with a fixed
						orthonormal basis states \(B=\left\{|0\rangle,|1\rangle\right\}\) when the <a
							class="sliding-link" href="#bases-measurments">base measurment</a> is in the \(Z\) basis.
						States
						\(|0\rangle\)
						and \(|1\rangle\) are the basis states, denoted with <a class="sliding-link"
							href="#dirac-notation">Dirac
							notation</a>.
						</p>

						<p>
							The states of the quantum system or qubit can be denoted as a vector like:
						</p>

						<p>
							\(\alpha|0\rangle + \beta|1\rangle\)
						</p>

						<p>
							This vector has a unit length of \(1\), so
							\(|\alpha|^{2} + |\beta|^{2}=1\). \(|\alpha|^{2}\) and \(|\beta|^{2}\) are the probabilities
							of the
							system being in the representative states.
							Meaning that the probabilities that when the qubit is measured will give a state \(0\) or
							\(1\) in this two-level quantum system. We will go more in depth into probabilites here
							soon.
						</p>

						<p>
							But first, we will look at formal definition of the inner dot product of some given some
							qubit \(\theta\).
							For \(|\theta\rangle\) the unit length is equivalant to its inner
							product. Where, for ket \(|\theta\rangle\) and
							bra \(\langle\theta|=(a^{*}b^{*})\), \(a,b\) are both complex numbers and both have two real
							numbers. The
							inner dot product is
							\(|\theta\rangle|\theta^{*\intercal}\rangle=|\theta\rangle|\theta^{\dagger}\rangle\),
							formulated as:
						</p>

						<p>
							\(\langle\theta|\theta\rangle=(a^{*}b^{*})\begin{pmatrix}a\\b\end{pmatrix}=|a|^{2}+|b|^{2}=1\)
						</p>

						<p>
							For some quantum state for the qubit \(\psi\) can be defined as:
						</p>

						<p>
							\(|\psi\rangle=\begin{pmatrix}\cos(\theta)\\ \sin(\theta)\end{pmatrix}\)
							<br><br>\(=\langle v|\psi\rangle|v\rangle+\langle h|\psi\rangle|h\rangle\)
						</p>

						<p>
							Where, squaring our projections, \(\langle v|\psi\rangle\) and \(\langle h|\psi\rangle\),
							onto axis an
							axis gives us our respective probabilites for \(|v\rangle\) and \(|h\rangle\) respectfully.
						</p>

						<p>
							An example of a qubit is the spin of an
							electron. The two levels of this quibit are spin up or spin down. What differs from
							a classical system is that quantum mechanics allows for the qubit to be in a
							coherent superposition of both states simultaneously.
						</p>

						<p>
							Measuring a qubit in a basis gives a projective measurement of a qubit of state \(\phi\) in
							its
							computational basis can be expressed as a linear combination of state vectors, such as:
						</p>

						<p>
							\(|\psi\rangle=\alpha|0\rangle+\beta|1\rangle\)
						</p>

						<p>
							When the qubit is measured in a basis, collapses the qubit to either the quantum state
							\(|0\rangle\)
							or \(|1\rangle\) given by the respective norm-square of the probability amplitudes
							\(\alpha\) and
							\(\beta\),
							or \(\alpha^{2}\) and \(\beta^{2}\).
						</p>
					</div>

					<div class="subsubsection-header-div">
						<p class="subsubsection-header" id="bloch-sphere">Bloch Sphere</p>

						<img src="/assets/images/bloch-sphere.png" alt="Bloch Sphere" class="figure"
							style="width:20%;height:auto;padding:3%3%;">

						<p>
							We can use a bloch ball or sphere to help us visualize sping down
							\(0\) and spin up \(1\) of a single qubit. The bloch spehere has a radius of
							1, meaning that \(|0\rangle\) corresponds to \((x,y,z)\) point \((x,y,1)\) and
							\(|1\rangle\) corresponds to \((x,y,z)\) point \((x,y,-1)\). Where our \(z\)
							value shows a spin up or sping down.
						</p>
					</div>

					<div class="subsubsection-header-div">
						<p class="subsubsection-header" id="superposition">Superposition</p>

						<p>
							In classical computing, states \(0\) and \(1\) would be the only states that
							exist for the bit. However, in quantum mechanics a quibit can be both in the
							state of \(|0\rangle\) and \(|1\rangle\). This is what gives quantum computers
							more processing power, as a single qubit can be in more states and therefore
							represent more information than a single classical bit.
						</p>

						<p>
							This means that the qubit can have an \(80\)% of being in state \(|0\rangle\) and
							\(20\)% of being in state \(|1\rangle\), or \(75\)% of being in state \(|0\rangle\) and
							\(25\)% of being in state \(|1\rangle\). Unlike a classical bit where there is either
							a \(100\)% of the classical bit being in state \(0\) and
							\(0\)% of being a \(1\) or a \(0\)% of the classical bit being a \(0\) and
							\(100\)% of being a \(1\). To allow for the qubit to be in superposition, we
							need to levearage Hilbert Space. Again, Hilbert space is represented using
							complex vector space. We use complex vector space, because it is the easiest way
							for the math to work.
						</p>

						<p>
							Let's represent this qubit in superposition as a vector using dirac notation.
							For the qubit have, for example, a \(50\)% of being in state \(|0\rangle\) and
							\(50\)% of being in state \(|1\rangle\), the vector should look like:
						</p>

						<p>
							\(\frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)\)
						</p>

						<p>
							The coefficent for \(0\) and \(1\) are both \(\frac{1}{\sqrt{2}}\) and therefore
							equal parts \(0\) and \(1\).
						</p>

						<!-- <p>
							An esemble is a collection \(\mathcal{E} =
							\left\{(p_{1},|\Psi_{1}\rangle),...,(p_{n},|\Psi_{n}\rangle)\right\}\)
							where \(|\Psi\rangle_{i}\in\mathbb{C}\), \(p_{i}\geq 0\) and \(\sum_{i=1}^{d}p_{i}=1\).
						</p>

						<p>
							Now, for the case \(d=2\), the set of density matrics has the following description.
							Using the Pauli matrices \(\sigma_{i}\) and the identity, constitute a basis for the
							space of \(2 \times 2\) Hermation matrices. Thus, we can write:
						</p>

						<p>
							\(\rho = \frac{a_{0}\Pi + a_{1}\sigma_{1} + a_{2}\sigma_{2} + a_{3}\sigma_{3}}{2}\)
						</p>

						<p>
							where \(a_{i} \in \mathbb{R}\).
						</p>

						<p>
							To continue.
						</p> -->
					</div>

					<!-- <div class="subsubsection-header-div">
						<p class="subsubsection-header" id="quantum-operator-as-matrices">Quantum Operator as Matrices</p>

						<p>
							A density matrix, or a density operator, is a matrix that represents a quantum state of a
							physical system. Density matrices allows for the calculation of the probabilities of the
							outcomes of any measurement performed on the system. In operator language, the quantum
							operations are represented as completely positive trace-preserving linear maps.
						</p>

						<div class="categories" style="overflow: hidden;">
							<p>Ensembles of Quantum States</p>
						</div>

						<p>
							To better understand density matrics, we should first disccus ensembles of quantum states.
							An esemble is a collection \(\mathcal{E} =
							\left\{(p_{1},|\Psi_{1}\rangle),...,(p_{n},|\Psi_{n}\rangle)\right\}\)
							where each \(|\Psi\rangle_{i}\in\mathbb{C}^{d}\), \(p_{i}\geq 0\) and \(\sum_{i=1}^{d}p_{i}=1\). What
							an ensemble \(\mathcal{E}\) refers to is the event that the quantum system is in state
							\(\Psi_{1}\) with probability \(p_{1}\), or in state \(\Psi_{2}\) with probability \(p_{2}\),
							and so on.
						</p>

						<p>
							Now, to continue with density matrices. Density matrices are an esemble of pure states.
							In the following steps, we will (I) first define a general quantum operator \(\rho\), (II)
							how to transform the quantum operation into a matrix form, and (III) look at the resulting matrix.
							The resulting matrix allows for eaiser linear computations later on for quantum operations.
						</p>

						<p>
							<b>I.</b> To begin, a density operator is deinfed as:
						</p>

						<p>
							\(\rho = \sum_{i=1}^{d}\lambda_{i}|\Psi_{i}\rangle \langle\Psi_{i}|\)
						</p>

						<p>
							where \(\rho \succeq 0\) meaning \(\lambda_{i} \geq 0\)
							and \(tr(\rho)\) means \(\sum_{i=1}^{d}p_{i}=1\).
						</p>

						<p>
							<b>II.</b> We can now define a function, so that when we pass the density
							matrix through it, that can be represented as vectors.
							This function is defined as \(vec(|x\rangle\langle y|) =
							|x\rangle |y\rangle\), where
							\(x,y \in \Sigma^{n}\) and \(n \in \mathbb{N}\) and our vector
							is indexed by \(\Sigma^{\mathbb{N}}\). This function
							or mapping returns a column vector from the matrix by reading
							each entry of the matrix in rows from left to right, beginning at
							the first column and top row and ending at the last row and column.
							An example of this mapping is:
						</p>

						<p>
							\(vec\left(\begin{bmatrix}\alpha & \beta \\\gamma & \delta \end{bmatrix}\right)
							=
							\left(\begin{array}{c}\alpha\\ \beta \\\gamma \\\delta\end{array}\right)\)
						</p>

						<p>
							Next, we can use our \(vec\) function to express this quantum
							operation as a matrix through the means of equality:
						</p>

						<p>
							\(vec(\Phi\left(\rho\right)) = \left(\sum_{j=1}^{k}A_{j} \otimes \overline{A_j}\right)vec(\rho)\)
						</p>

						<p>
							where \(\otimes\) is the tensor product of the two vectors \(A_{j}\) and \(\overline{A_j}\).
						</p>

						<p>
							<b>III.</b> The resulting matrix is:
						</p>

						<p>
							\(M_{\Phi} = \sum_{j=1}^{k}A_{j}\otimes \overline{A_j}\)
						</p>
					</div> -->

					<div class="subsubsection-header-div">
						<p class="subsubsection-header" id="pauli-matrices">Pauli Matrices</p>
						<p>
							Pauli matrices have a core importance in quantum physics, and when combinex with an identity
							matrix,
							pauli
							matrices form a basis for all single quantum gates. Pauli matrices are defined as:
						</p>

						<p>
							\(\sigma_{x}=\begin{pmatrix}
							0&1 \\
							1&0
							\end{pmatrix}\),
							<br>
							<br>
							\(\sigma_{y}=\begin{pmatrix}
							0&-i \\
							i&0
							\end{pmatrix}\),
							<br>
							<br>
							\(\sigma_{z}=\begin{pmatrix}
							1&0 \\
							0&-1
							\end{pmatrix}\)
						</p>

						<p>
							\(\sigma_{x}\) is usally refered to as the NOT gate and can be written as \(X\). The NOT
							gate inverts
							\(|0\rangle\) and \(|1\rangle\) and \(\sigma_{y}\), \(\sigma_{z}\) are phase shifting gates.
						</p>
					</div>
				</div>

				<div class="subsection-header-div">
					<p class="subsection-header" id="multiple-qubits">Multiple Qubits</p>
					<div class="subsubsection-header-div">
						<p class="subsubsection-header" id="quantum-registers">Quantum Registers</p>

						<p>
							A system that contains more than one qubit is represented in a quantum register. A system
							with two qubits is represented using a four-dimensional Hilbert space
							\(H_{4} = H_{2} \otimes H_{2}\). The orthonormal basis is
							\(\left\{|0\rangle |0\rangle, |0\rangle |1\rangle, |1\rangle |0\rangle, |1\rangle |1\rangle\
							\right\}\).
							\(|0\rangle |0\rangle\) can be more succinctly written as \(|00\rangle\). The same is true
							for
							\(|0\rangle |1\rangle = |01\rangle\), etc. A state of this two-qubit system, a part from
							four-dimensional
							Hilbert space is a unit-length vector:
						</p>

						<p>
							\(c_{0}|00\rangle + c_{1}|01\rangle + c_{2}|10\rangle + c_{3}|11\rangle\)
						</p>

						<p>
							Again, as it is with a single qubit, it is required that
							\(|c_{0}|^{2} + |c_{1}|^{2} + |c_{2}|^{2} + |c_{3}|^{2} = 1\).
						</p>

						<p>
							Observations of this two-qubit system will give \(00\), \(01\), \(10\), and \(11\) with the
							outcomes
							\(|c_{0}|^2, |c_{1}|^2, |c_{2}|^2, |c_{3}|^2\), respectively. If we want to observe one of
							the
							qubits, then the standard rules of probabilities apply.
						</p>

						<p>
							It is important to note that the tensor product of these vectors does not commute. Meaning,
							that
							\(|0\rangle|1\rangle \neq |1\rangle|0\rangle\). Linear ordering is used to address the
							qubits
							individually.
						</p>
					</div>

					<div class="subsubsection-header-div">
						<p class="subsubsection-header" id="quantum-entanglement">Quantum Entanglement</p>
						<div class="subsubsubsection-header-div">
							<p class="subsubsubsection-header" id="maximally-engtanlged-bell-states">Maximally Entangled
								Bell
								States
							</p>
							<p>
								Bell states or Einstein, Podolski and Rosen pairs are the maximally entangled quantum
								states of a
								qubit
								system such that a quantum mechanical system is composed of two interacting two-level
								subsystems.
								The 4 types of maximially entangled Bell states can be defined as:
							</p>

							<p>
								\(|\Phi^{+}\rangle = \frac{|00\rangle+|11\rangle}{\sqrt{2}}\)
								<br>
								<br>
								\(|\Phi^{-}\rangle = \frac{|00\rangle-|11\rangle}{\sqrt{2}}\)
								<br>
								<br>
								\(|\Psi^{+}\rangle = \frac{|01\rangle+|10\rangle}{\sqrt{2}}\)
								<br>
								<br>
								\(|\Psi^{-}\rangle = \frac{|01\rangle-|10\rangle}{\sqrt{2}}\)
							</p>
						</div>
					</div>
				</div>
				<div class="subection-header-div">
					<p class="subsection-header" id="measurments">Measurments</p>
					<div class="subsubection-header-div">
						<p class="subsubsection-header" id="bases-measurments">Bases Measurments</p>
						<p>
							The orthagonal basis states for \(Z\), \(X\), and \(Y\), are as follows:
						</p>

						<ul>
							<li>\(Z=\{|0\rangle,|1\rangle\}\)</li>
							<li>\(X=\{|-\rangle,|+\rangle\}\)</li>
							<li>\(Y=\{|i\rangle,|-i\rangle\}\)</li>
						</ul>

						<div class="subsubsubection-header-div">
							<p class="subsubsubsection-header" id="x-bases-measurment">X Bases Measurment</p>
							<p>
								To measure from the \(Z\) basis to the \(X\) bases, we need to apply a Hadmard gate to
								the state,
								allowing
								for
								the state to be halfway:
							</p>

							<p>
								\(H|0\rangle=|+\rangle=\begin{pmatrix}\frac{1}{\sqrt{2}}\\
								\frac{1}{\sqrt{2}}\end{pmatrix}=\frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)\)<br><br>
								\(H|1\rangle=|-\rangle=\begin{pmatrix}\frac{1}{\sqrt{2}}\\
								-\frac{1}{\sqrt{2}}\end{pmatrix}=\frac{1}{\sqrt{2}}(|0\rangle-|1\rangle)\)
							</p>
						</div>

						<div class="subsubsubection-header-div">
							<p class="subsubsubsection-header" id="y-bases-measurment">Y Bases Measurment</p>
							<p>
								Then to measure from the \(Z\) basis to the \(Y\) bases, we need to apply a Hadmard gate
								to the state,
								allowing for
								the state to be halfway we need to apply \(S^{*\intercal}=S^{\dagger}\):
							</p>

							<p>
								\(=\frac{1}{\sqrt{2}}\begin{pmatrix}1
								& -i\\1
								& i
								\end{pmatrix}^{\dagger}=\frac{1}{\sqrt{2}}\begin{pmatrix}1
								& 1\\i
								& -i
								\end{pmatrix}\)
							</p>
						</div>
						<div class="subsubsubection-header-div">
							<p class="subsubsubsection-header" id="Z-bases-measurment">Z Bases Measurment</p>
							<p>
								No transformations needed, since we measure in the "normal" bases.
							</p>
						</div>
					</div>
				</div>

				<div class="subsection-header-div">
					<p class="subsection-header" id="operators">Operators</p>
					<div class="subsubsection-header-div">
						<p class="subsubsection-header" id="unitary-operator">Unitary Operator</p>

						<p>
							All quantum gates are unitary, which we will define in the following. Let us use the basis
							measurment of
							\(Z\) with the coordinate representation
							\(|0\rangle = \begin{bmatrix} 1\\ 0 \end{bmatrix}\) and
							\(|1\rangle = \begin{bmatrix} 0\\ 1 \end{bmatrix}\).
						</p>

						<p>
							An operation on a quibit, called an unary quantum gate, is a unitary mapping
							\(U: H_{2} \rightarrow H_{2}\) with the following defining linear operation:
						</p>

						<p>
							\(|0\rangle \mapsto a|0\rangle + b|1\rangle\)
							<br>
							\(|1\rangle \mapsto c|0\rangle + d|1\rangle\)
						</p>

						<p>
							An important aspect of all quantum gates is that they are unitary. Meaning, that for some
							given matrix
							operation \(U\), defined as:
						</p>

						<p>
							\(\begin{pmatrix} a & b \\ c & d \end{pmatrix}\)
						</p>

						<p>
							it is neccesary that this matrix is unitary in order to be a valid quatnum gate.
							So, for some matrix or operator \(U\) to be unitary and valid, the following equivalency
							must be true:
						</p>

						<p>
							\(UU^{\dagger}=I\)
						</p>

						<p>
							where \(U^{\dagger}\) represents the conjugate transpose and \(I\) is the identity matrix.
						</p>

						<p>
							Another important qualtiy of an unitary matrix is:
						</p>

						<p>
							\(U^{\dagger}=U^{-1}\)
						</p>

						<p>
							Represented as matrices, we get:
						</p>

						<p>
							\(\begin{pmatrix} a & b \\ c & d \end{pmatrix} \begin{pmatrix} a^* & b^* \\ c^* & d^*
							\end{pmatrix} =
							\begin{pmatrix} 1 & 0 \\ 0 & 1 \end{pmatrix}\)
						</p>

						<p>
							Written in vector form, the conjugate transpose of \(U\) is denoted as \(U^{\dagger}\) and
							can be wrriten
							as:
						</p>

						<p>
							\(\begin{pmatrix}a\\ d\end{pmatrix}^{\dagger}=\left(a^{*}d^{*}\right)\)
						</p>

						<p>
							where the notation \(a^{*}\) stands for the complex conjugate of the complex number \(a\).
							The complex conjugate of a complex number is the number with an equal real part and
							an imaginary part equal in magnitude, but opposite in sign of the complex number.
						</p>


						<p>
							The mapping of for unary quantum operator, when represented in a quantum circut, can be a
							quantum gate.
							Where
							the output of the quantum gate must have the same dimensionality as its input. So, \(U:
							H_{n} \rightarrow
							H_{n}\), where \(n\) is the number of dimensions of \(H\).
						</p>
					</div>

					<div class="subsubsection-header-div">
						<p class="subsubsection-header" id="hermitian-operator">Hermitian Operator</p>
						<p>
							A <a class="sliding-link" href="#unitary-operator">unitary operator</a> is Hermitian if:
						</p>

						<ul>
							<li>\(U^{\dagger}=U\), where \(U^{\dagger}\) is the conjugate transpose of the matrix \(U\).
							</li>
							<li>\(U^{2}=I\), where \(I\) is an identity matrix.</li>
						</ul>

						<p>
							A Hermatian matrix is a special case of a unitary matrix, where all Hermitian operators or
							unitary
							operators, but not all unitary operators, are Hermitian.
						</p>
					</div>

					<div class="subsubsection-header-div">
						<p class="subsubsection-header" id="natural-operator">Natural Operator</p>
						<p>
							An <a class="sliding-link" href="#hermitian-operator">Hermitian operator</a> is Natural if:
						</p>

						<ul>
							<li>\(U^{\dagger}U=UU^{\dagger}\), where \(U^{\dagger}\) is the conjugate transpose of
								\(U\).</li>
							<li>the operator has spectural decomposition, where \(U\) can be decomposed as:<br>
								\(U=\sum_{i}\lambda_{i}|\lambda_{i}\rangle\langle\lambda_{i}|\)
							</li>
						</ul>
					</div>
				</div>
			</div>

			<div class="section-header-div">
				<p class="section-header" id="quantum-algorithms">Quantum Algorithms</p>
				<div class="subsection-header-div">
					<p class="subsection-header" id="quantum-parallelism">Quantum Parallelism</p>
					<p>
						Suppose we want to evaluate a function \(f(x)\), where the function \(f\) expresses some
						computation or
						algorithm. A use case for quantum parallelism is to evaluate \(f(x)\) with many different values
						for the
						output of the computation or algorithm on the input \(x\) simultaneously. In essence, we can
						evaluate many
						different values of \(x\) on \(f\) in parallel by exploiting quantum effects. This quantum
						effect exploit
						feature is fundamental in many quantum algorithms. To continue, we will look at how quantum
						parallelism
						works.
					</p>

					<p>
						Consider the one-bit domain and range function
						\(f(x):\{0,1\}\rightarrow\{0,1\}\). To compute this function
						\(f\) on a quantum computer, we will use a two-qubit quantum computer with the starting state
						\(|x,y\rangle\). The transformation on the domain or 'data' register to the range or 'target'
						register of
						this initial two qubit state is described by the following unitary function:
					</p>

					<p>
						\(U_{f}:|x,y\rangle\rightarrow|x,y\oplus f(x)\rangle\)
					</p>

					<p>
						where the \(\oplus\) represents addition
						modulo 2 and \(x=q_{0}, y=q_{1}\). When \(\oplus\) acts on \(y\), and its value is \(0\) then
						the value
						of the second qubit in the 'target' register is the
						value \(f(x)\), given whatever function \(f\) represents. The functions effect on \(x\) is
						arbritrary for
						now.
					</p>

					<p>
						The final collapsed state \(|\psi\rangle\) is an element of the set of final states or 'target'
						register
						\(|x,y\oplus f(x)\rangle\), which again is given by the unitary transformation \(U_{f}\) on the
						start
						state \(|x,y\rangle\).
					</p>

					<p>
						Given the input \(q_{0}=x=|0\rangle\), we will apply the Hadmard gate \(H\) to \(x\), such that
						now:
					</p>

					<p>
						\(x=\frac{|0\rangle+|1\rangle}{\sqrt{2}},y=|0\rangle\)
					</p>

					<p>
						where the resulting state is:
					</p>

					<p>
						\(\frac{|0 f(0)\rangle+|1 f(1)\rangle}{\sqrt{2}}\)
					</p>

					<p>
						which the resulting new state is not apart of the starting
						computational basis
						\(\{0,1\}\). Next, the unitary function or blackbox
						computation/algorithm \(U_{f}\) can be applied to the current 'data' register. The resulting
						mapping of the unitary function \(U_{f}\) is:
					</p>

					<p>
						\(U_{f}\left(\frac{|0\rangle+|1\rangle}{\sqrt{2}},|0\rangle\right)=\frac{|0, f(0)\rangle+|1,
						f(1)\rangle}{\sqrt{2}}\)
					</p>

					<p>
						\(=\frac{1}{\sqrt{2}}(|0,f(0)\rangle+|1,f(1)\rangle)\)<br><br>\(=.5|0,f(0)\rangle+.5|1,f(1)\rangle\)
					</p>

					<p>
						Meaning that the final resulting state for a two-qubit quantum computer has a \(50\)% chance of
						being
						\(|0,f(0)\rangle\) and \(50\)% of being
						\(.5|1,f(1)\rangle\). Given in the same form as the range for \(U_{f}\) given above:
					</p>

					<p>
						\(|x,y'\rangle\), where \(y'=y\oplus f(x)\)
					</p>

					<p>
						All of this means that the information given by the mapping for \(f(0)\) and \(f(1)\) was
						simultaneously evaluated by applying
						superposition and the unitary function on the starting 'data' register. Thus, \(f(x)\) has been
						computed for two values of \(x\) in parellel. The resulting set of all possible states computed
						in parallel
						is given by the resulting 'target' register is given by quantum exploitation and aptly named
						'quantum
						parallelism'. Thus, a single \(f(x)\) circuit can be used to evaluate the result for \(n\)
						values of \(x\)
						simultaneously.
					</p>

					<!-- <div class="subsection-header-div">
						<p class="subsection-header" id="n-qubit-quantum-parallelism">N-Qubit Quantum Parallelism</p>
						<p>
							To contine.
						</p>
					</div> -->
				</div>

				<div class="subsection-header-div">
					<p class="subsection-header" id="deutschs-algorithm">Deutsch's Algorithm</p>
					<p>
						Consider a two-qubit system such that \(q_{0}=x=|0\rangle,q_{1}=y=|0\rangle\). Now, let's apply
						the NOT gate
						to \(y\), giving
						the what will be the start state \(|\psi_{0}\rangle=|01\rangle\). Next, we will apply a Hadmard
						gates to
						\(x\) and
						\(y\) individually, yielding the state:
					</p>

					<p>
						\(|\psi_{1}\rangle=\left[\frac{|0\rangle+|1\rangle}{\sqrt{2}}\right]\left[\frac{|0\rangle-|1\rangle}{\sqrt{2}}\right]\)
					</p>

					<p>
						where for state \(|\psi_{1}\rangle\):
					</p>

					<p>
						\(x=\frac{|0\rangle+|1\rangle}{\sqrt{2}}\)
						<br>
						\(y=\frac{|0\rangle-|1\rangle}{\sqrt{2}}\)
					</p>

					<p>
						Applying some arbritrary unitary function \(U_{f}\) on \(|xy\rangle\) or \(|\psi_{1}\rangle\)
						gives:
					</p>

					<p>
						\(|\psi_{2}\rangle=\left(-1\right)^{f(x)}\left[\frac{|0\rangle-|1\rangle}{\sqrt{2}}\right]\left[\frac{|0\rangle-|1\rangle}{\sqrt{2}}\right]\)
					</p>

					<p>
						From this, we can then say that if \(f(0)=f(1)\):
					</p>

					<p>
						\(|\psi_{2}\rangle=\left[\frac{|0\rangle+|1\rangle}{\sqrt{2}}\right]\left[\frac{|0\rangle-|1\rangle}{\sqrt{2}}\right]\)
					</p>

					<p>
						or if \(f(0)\neq f(1)\):
					</p>

					<p>
						\(|\psi_{2}\rangle=\left[\frac{|0\rangle-|1\rangle}{\sqrt{2}}\right]\left[\frac{|0\rangle-|1\rangle}{\sqrt{2}}\right]\)
					</p>

					<p>
						Next step in Deutsch's algorithm is to apply a Hamdmard gate \(H\) to \(x\). If \(f(0)=f(1)\),
						the
						resulting state is:
					</p>

					<p>
						\(|\psi_{3}\rangle=\pm|0\rangle\left[\frac{|0\rangle-|1\rangle}{\sqrt{2}}\right]\)</p>
					<p>
						or if \(f(0)\neq f(1)\)
					</p>

					<p>
						\(|\psi_{3}\rangle=\pm|1\rangle\left[\frac{|0\rangle-|1\rangle}{\sqrt{2}}\right]\)
					</p>


					<p>
						This can then be written more succenctly as:
					</p>

					<p>
						\(|\psi_{3}\rangle=\pm f(0) \oplus f(1) \left[\frac{|0\rangle-|1\rangle}{\sqrt{2}}\right]\)
					</p>

					<p>
						Thus, \(f(0)\) interfers with \(f(1)\) when we simultaneously evalute \(f(x)\) with quantum
						parallelism.
					</p>
				</div>

				<div class="subsection-header-div">
					<p class="subsection-header" id="grovers-shors-algorithm">Grovers Search Algorithm</p>
					<div class="section-header-div">
						<p>
							The authors describe the process for Grovers Search Algorithm in the following sequential
							two main steps:
							<a class="sliding-link" href="#gsa-step1">Hadmard transformation</a> and <a
								class="sliding-link" href="#gsa-step2">Grover iteration or Grover operator \(G\)</a>.
						</p>

						<p id="gsa-step1"><i>Hadmard Transformation</i></p>
						<p>
							The Hadmard transform puts the qubits of the quantum computer into equal superposition
							states, defined as:
						</p>

						<p>
							\(|s\rangle=|+\rangle^{\otimes n}=\frac{1}{\sqrt{N}} \sum_{x \in\{0,1\}^n}|x\rangle\)
						</p>

						<p id="gsa-step2"><i>Grover Operation</i></p>
						<p>
							Grovers search algorithm implements a repeated quantum subroutine called Grover iteration or
							operator,
							denoted as \(G\). This quantum iteration can be broken up in four steps:
						</p>

						<ol>
							<li>Apply oracle \(O\)</li>
							<li>Apply Hadmard transform \(H^{\otimes{n}}\)</li>
							<li>Apply conditional phase shift on quantum register, such that every quantum basis state
								except
								\(|r\rangle\) is phased shifted \(-1\). Meaning that for unitary:</li>
							<p>
								\(\begin{aligned}
								U_f|s\rangle & =(-1)^1 \sin \theta|w\rangle \\
								& +(-1)^0 \cos \theta|r\rangle \\
								& =-\sin \theta|w\rangle+\cos \theta|r\rangle
								\end{aligned}\)
							</p>
							<p>
								This phase kicks \(|w\rangle\) only. Then, reflect the state around \(|s\rangle\) using
								gate \(R_{s}\), such that moving our state towards \(|w\rangle\).
							</p>
							<li>
								Lastly, apply the Hadmard transform \(H^{\otimes{n}}\)
							</li>
						</ol>

						<p>
							Where combined steps of 2, 3, 4, or Grovers iteration without the oracle step can be written
							as:
						</p>

						<p>
							\(H^{\otimes n}(2|0\rangle\langle 0|-I) H^{\otimes n}=2|\psi\rangle\langle\psi|-I\)
						</p>

						<p>
							where \(|\psi\rangle\) is equaly eighted superposition of states \(\frac{1}{N^{1 / 2}}
							\sum_{x=0}^{N-1}|w\rangle\). Thus, including the oracle step now, Grovers iteration \(G\) as
							a whole can
							be
							written, more generically for a given quantum state \(\psi\) as
							\(G=(2|\psi\rangle\langle\psi|-I) O\). The circut is given as:
						</p>

						<img src="/assets/images/grover-search-circut.png" alt="Grovers Search Circut" class="figure"
							style="width:55%;height:auto;padding:1%1%;">

						<p class="figure-source-txt" id="section-reference-2">
							Image Source:
							<a class="sliding-link" href="#section-reference-1">
								\(^{[1]}\)
							</a>
						</p>
					</div>

					<p>
						To continue.
					</p>
				</div>
			</div>

			<div class="section-header-div">
				<p class="section-header" id="quantum-computational-theory">Quantum Computational Theory</p>

				<div class="subsection-header-div">
					<p class="subsection-header" id="quantum-automate-theory">Quantum Automata Theory</p>

					<div class="subsubsection-header-div">
						<p class="subsubsection-header" id="quantum-turing-machine">Quantum Turing Machine</p>

						<div class="categories" style="overflow: hidden;">
							<p>QTM</p>
							<p>\(\delta\) Function</p>
						</div>

						<p>
							A Quantum Turing Machine QTM can be expressed similarly to a traditional Turing Machine
							TM with all components reformulated canonically <i>except</i>
							for the transition function \(\delta\). Below, is the formal definition of a QTM.
						</p>

						<p>Quantum Turing Machine is a 7-tuple:</p>

						<p>
							\((Q, \Sigma, \Gamma, \delta, q_{0}, q_{accept}, q_{reject})\)
						</p>

						<p>
							where \(Q, \Sigma, \Gamma\) are all finite sets and:
						<ul>
							<li>\(Q\) is a set of states</li>
							<li>\(\Sigma\) is an alphabet not containing the blank symbol \(\sqcup\)</li>
							<li>\(\Gamma\) is the tape alphabet, where \(\sqcup \in \Gamma\) and \(\Sigma \subseteq
								\Gamma\).
								The tape is assumed to be two-way infinite, with squares indexed by the set of integers
								\(\mathbb{Z}\)
							</li>
							<li>\(\delta\) is a transition function described as
								\(\delta : Q \times \Gamma \rightarrow \mathbb{C}^{Q \times \Gamma \times \left\{-1,
								+1\right\}}\)
							</li>
							<li>\(q_{0} \in Q\) is the initial state</li>
							<li>\(q_{accept} \in Q\) is the accept state</li>
							<li>\(q_{reject} \in Q\) is the reject state, where \(q_{reject} \neq q_{accept}\)</li>
						</ul>
						</p>

						<img src="/assets/images/quantum-turing-machine.png" alt="Quantum Turing Machine State Diagram"
							class="figure" style="width:40%;height:auto;padding:3%3%;">

						<p class="figure-source-txt">
							Image Source: <a target="_blank" rel="noopener noreferrer"
								href="https://www.mdpi.com/applsci/applsci-10-05551/article_deploy/html/images/applsci-10-05551-g004.png">https://www.mdpi.com/applsci/applsci-10-05551/article_deploy/html/images/applsci-10-05551-g004.png</a>
						</p>
					</div>
				</div>
			</div>

			<div class="section-header-div">
				<p class="section-header" id="quantum-networks">Quantum Networks</p>
				<div class="subsection-header-div">
					<p class="subsection-header" id="superdense-coding-and-quantum-teleportation">Superdense Coding and
						Quantum
						Teleportation</p>

					<div class="subsubsection-header-div">
						<p class="subsubsection-header" id="supderdense-coding">Superdense Coding</p>
						<p>
							Given Alice wants to send classical information to Bob, quantum entanglement \(n\) qubits
							can store
							\(2n\) qubits total of information. Say Alice needs to send one qubit of infromation, they
							can do so
							but
							needs Bob to <i>already</i> share a second qubit. So, given that Alice and Bob already share
							a pair of
							entangled qubits in state \(|\Phi^{+}\rangle\), defined as:
						</p>

						<p>
							(Alice) -- \(\frac{1}{\sqrt{2}}(|00\rangle+|11\rangle)\) -- (Bob)
						</p>

						<p>If Alice wants to send:</p>

						<ul>
							<li>\(00\): Alice does nothing to their qubit, so the qubit is still in state:</li>
							<p>
								\(|\Phi^{+}\rangle=\frac{1}{\sqrt{2}}(|00\rangle+|11\rangle)\)
							</p>

							<li>\(01\): Alice applies \(X\) gate to their qubit, transforming \(|\Phi^{+}\rangle\) to:
							</li>
							<p>
								\(|\Psi^{+}\rangle=\frac{1}{\sqrt{2}}(|10\rangle+|01\rangle)\)
							</p>

							<li>\(10\): Alice applies \(Z\) gate to their qubit, transforming \(|\Phi^{+}\rangle\) to:
							</li>
							<p>
								\(|\Phi^{-}\rangle=\frac{1}{\sqrt{2}}(|00\rangle-|11\rangle)\)
							</p>

							<li>\(11\): Alice applies \(X\) and \(Z\) gate to their qubit, transforming
								\(|\Phi^{+}\rangle\) to:
							</li>
							<p>
								\(|\Psi^{-}\rangle=\frac{1}{\sqrt{2}}(|01\rangle-|10\rangle)\)
							</p>
						</ul>

						<p>
							Not that Bob has both qubits in one of four Bell basis, Bob will know what the qubit Alice
							wants to
							send
							by measuring the two qubits and seeing what state they are in. This is called a Bell
							measurment. If we
							then extrapolate this method, then if Alice and Bob want to share \(n\) pairs of entangled
							qubits they
							can do so with \(2n\) quibits in total.
						</p>
					</div>

					<!-- <p>
							Suppose Alice and Bob have a shared state:
						</p>
						<p>
							\(|\Phi^{+}\rangle=\frac{1}{\sqrt{2}}\left(|0\rangle\otimes|0\rangle+|1\rangle\otimes|1\rangle\right)\)
						</p>
						<p>
							Now, suppose we want to add Charlie's quibit to this state. The issue is that we cannot, because we
							cannot add a "quantum qubit" to the entangled stated. Thus, Alice cannot bring an entangled quatnum
							state
							with Charlie. The important past is that you cannot join a entangled qubit within another entagled
							state,
							thus this is not a three party englangled state between Alice, Bob, and Charlie is:
						</p>
						<p>
							\(\frac{1}{\sqrt{2}}(|0\rangle\otimes|0\rangle+|1\rangle\otimes|1\rangle\otimes|\Psi_{c}\rangle)\)
						</p>

						<p>
							In order to generate a tripartite entlangled states or Greenberger-Horne-Zeilinger GHZ state like:
						</p>

						<p>
							\(\frac{1}{\sqrt{2}}(|000\rangle+|111\rangle)\)
						</p>

						<p>
							The states must start entangled. One way to do this, is a change of a basis \(+\) and a gate, which can
							produce a Bell pair such as:
						</p>

						<p>
							\(|GHZ\rangle=\frac{1}{\sqrt{2}}(|000\rangle+|111\rangle\)<br>
							\(=\frac{1}{\sqrt{2}}(|00\rangle+|11\rangle)\otimes|+\rangle\)<br>\(+\frac{1}{\sqrt{2}}(|00\rangle-|11\rangle)\otimes|-\rangle\)
						</p> -->

					<div class="subsubection-header-div">
						<p class="subsubsection-header" id="quantum-teleportation">Quantum Teleportation</p>
						<p>
							To continue.
						</p>
					</div>
				</div>
			</div>

			<div class="section-header-div">
				<p class="section-header" id="glossary">Glossary</p>

				<div class="subsection-header-div">
					<p class="subsection-header" id="hilbert-space">Hilbert Space</p>
					<p>
						Hilbert Space is a nondenumerable infinite complex vector space. Complex space,
						being a collection of complex numbers \(\mathbb{C}\) with an added structure.
						The infinite dimensions of Hilbert Space represents a continious spectra of alternative physical
						states. Alternative physical states, for example, being the position (coordinates) or
						momentum of a particle.
					</p>
				</div>

				<div class="subsection-header-div">
					<p class="subsection-header" id="probabilistic-systems">Probabilistic Systems</p>

					<div class="categories" style="overflow: hidden;">
						<p>Pure States</p>
						<p>Mixed States</p>
					</div>

					<p>
						The nature of a probabilistic system is that we do not know for
						certain the state of the system. However, we do know the probability
						distribution of the states. Our probabilistic distribution sums up to
						1. The notation can be written as:
					</p>

					<p>
						\(p_{1}[x_{1}] + p_{2}[x_{2}] + ... + p_{n}[x_{n}]\)
					</p>

					<p>
						\(x_{i}\) stands for the state the system is in with probability
						\(p_{i}\). Where \(p_{i} \ge 0\) and \(p_{1} + ... + p_{n} = 1\). Our
						distribution defined above is a mixed state. Where \(x_{i}\) is a
						pure state. It is important to note that our distribution is not
						an expected value or an average of the mixed state, but rather
						represents <i>only</i> the <i>probability distribution</i> for all
						states \(x_{i}\).
					</p>
				</div>

				<div class="subsection-header-div">
					<p class="subsection-header" id="hilbert-space-formalism">Quantum Mechanics Fun</p>

					<p>
						From here on out we used will use a Hilbert space formalism
						of quantum mechanics where the representation of quantum mechanical
						systems are represented as state vectors. We use this representation
						because state vectors are mathematically simpler that the more
						general ones.
					</p>

					<p>
						The quantum mechanical description of a physical system resembles the
						probabilistic systems we mentioned earlier:
					</p>

					<p>
						\(p_{1}[x_{1}] + p_{2}[x_{2}] + ... + p_{n}[x_{n}]\)
					</p>


					<p>
						An \(n\)-level system in quantum mechanics can be shown as a unit-length vector in
						\(n\)-dimensional complex vector space. We define this state
						space with \(H_{n}\). Using ket-notation, which is a part of Dirac notation,
						we define our state space
						\(H_{n}\) as an orthonormal basis \(\left\{\left| x_{1} \right>,...,\left| x_{n}
						\right>\right\}\). We can now write any state of the quantum system as:
					</p>

					<p>
						\(\alpha_{1}\left| x_{1} \right> + \alpha_{2}\left| x_{2} \right> +
						... + \alpha_{n}\left| x_{n} \right>\)
					</p>

					<p>
						Here, \(\alpha_{i}\) are probabilistic amplitudes. Finally, to meet our
						requirements defining our state space \(H_{n}\) as unit-length we say that
						\(|\alpha_{1}|^{2} + |\alpha_{2}|^{2} + ... + |\alpha_{n}|^{2} = 1\).
					</p>
					<p>
						This concludes most of the information neccesary for this page. However, if you are having fun
						with
						quantum
						mechanics, feel free to read more on my <a
							href="https://context-switching.com/math/quantummechanics">Quantum
							Mechanics</a> page.
					</p>
				</div>
			</div>
		</div>
	</div>
	</div>

	<!--Collapsible table of contents-->
	<div class="table-of-contents-collapsible-div"></div>
	<!-- end of collapsible table of contents -->

	<!-- Footer bar -->
	<div class="footer-placeholder" id="footer-placeholder"></div>
	<!-- end of Footer bar -->

	<!-- sources: https://royalsocietypublishing.org/doi/10.1098/rspa.2018.0767, 
	https://plato.stanford.edu/entries/qt-quantcomp/#QuanCirc, 
	https://people.eecs.berkeley.edu/~vazirani/pubs/bv.pdf, 
	https://encyclopediaofmath.org/wiki/Quantum_Turing_machine -->

	<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
		integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
		crossorigin="anonymous"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
		integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
		crossorigin="anonymous"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
	<script src="/assets/js/preset-divs.js"></script>
	<script src="/assets/js/helper-functions.js"></script>
	<script src="/assets/js/script.js"></script>
</body>

</html>