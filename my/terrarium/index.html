<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Artificial Terrarium</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --primary: #2d5016;
            --accent: #9dc183;
            --water: #4a90e2;
            --bg-dark: #0f1419;
            --bg-card: #1a1f2e;
            --text-light: #e8eef5;
            --text-muted: #8b92a9;
            --success: #6ec96e;
            --danger: #e74c3c;
        }

        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, var(--bg-dark) 0%, #1a2332 100%);
            color: var(--text-light);
            font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        body {
            display: flex;
            flex-direction: column;
            height: 100dvh;
        }

        /* Header */
        .header {
            padding: 12px 16px;
            background: rgba(15, 20, 25, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(157, 193, 131, 0.2);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .header h1 {
            font-size: 20px;
            font-weight: 700;
            font-family: 'Source Serif 4', serif;
            color: var(--accent);
            margin: 0;
            letter-spacing: -0.5px;
        }

        /* Canvas Container */
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            min-height: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #0a0a0a;
        }

        canvas {
            border: none;
            /* background-color: #0a0a0a; */
            cursor: crosshair;
            display: block;
            image-rendering: pixelated;
            touch-action: manipulation;
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
        }

        #canvas {
            position: relative;
            z-index: 1;
        }

        #nn-canvas {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            pointer-events: none;
            opacity: 1;
        }

        #nn-canvas.visible {
            display: block;
        }

        /* Controls Section */
        .controls-section {
            padding: 12px 16px;
            background: rgba(26, 31, 46, 0.9);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(157, 193, 131, 0.2);
            overflow-y: auto;
            max-height: 35vh;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 12px;
        }

        button {
            padding: 10px 14px;
            background: linear-gradient(135deg, var(--primary) 0%, #3d6b1f 100%);
            color: var(--text-light);
            border: 1px solid var(--accent);
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s ease;
            font-family: 'Poppins', sans-serif;
            active: scale(0.95);
        }

        button:active {
            transform: scale(0.95);
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.3);
        }

        button:hover {
            background: linear-gradient(135deg, #3d6b1f 0%, #4a7d24 100%);
            border-color: var(--accent);
            transform: translateY(-1px);
        }

        button.paused {
            background: linear-gradient(135deg, var(--success) 0%, #5aad5a 100%);
            border-color: var(--success);
        }

        button.wide {
            grid-column: 1 / -1;
        }

        /* Speed Control */
        .control-group {
            margin-bottom: 12px;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 6px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: rgba(157, 193, 131, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(157, 193, 131, 0.3);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(157, 193, 131, 0.3);
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 12px;
        }

        .stat-card {
            padding: 10px;
            background: rgba(157, 193, 131, 0.08);
            border: 1px solid rgba(157, 193, 131, 0.2);
            border-radius: 6px;
            text-align: center;
        }

        .stat-label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
            font-weight: 600;
        }

        .stat-value {
            font-size: 22px;
            font-weight: 700;
            color: var(--accent);
            font-family: 'Source Serif 4', serif;
        }

        .stat-card.day .stat-value {
            color: #ffa500;
        }

        /* Info Panel */
        .info-panel {
            max-height: 200px;
            padding: 12px;
            background: rgba(157, 193, 131, 0.1);
            border: 1px solid var(--accent);
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.6;
            color: var(--text-light);
            overflow-y: auto;
            display: none;
            margin-bottom: 12px;
        }

        .info-panel.visible {
            display: block;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .info-panel strong {
            color: var(--accent);
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .info-panel p {
            margin: 4px 0;
        }

        /* Tablet and Desktop Adjustments */
        @media (min-width: 768px) {
            .header {
                padding: 16px 24px;
            }

            .header h1 {
                font-size: 28px;
            }

            .controls-section {
                padding: 16px 24px;
                max-height: none;
                flex: 0 0 auto;
                display: flex;
                gap: 24px;
                align-items: flex-start;
            }

            .controls-grid {
                grid-template-columns: auto auto auto;
                gap: 12px;
                margin-bottom: 0;
                flex: 1;
            }

            button {
                padding: 10px 16px;
                font-size: 14px;
            }

            button.wide {
                grid-column: auto;
            }

            .control-group {
                flex: 1;
                min-width: 180px;
                margin-bottom: 0;
            }

            .stats-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 12px;
                flex: 1;
            }

            .stat-card {
                padding: 12px;
            }

            .stat-value {
                font-size: 24px;
            }

            .info-panel {
                font-size: 13px;
                padding: 16px;
                max-height: none;
            }
        }

        @media (min-width: 1024px) {
            .canvas-container {
                flex: 1;
            }

            .controls-section {
                border-top: 1px solid rgba(157, 193, 131, 0.2);
                border-left: none;
                padding: 16px 24px;
                background: rgba(26, 31, 46, 0.95);
            }
        }

        /* Mobile optimizations */
        @media (max-height: 600px) {
            .controls-section {
                max-height: 25vh;
            }

            .stat-value {
                font-size: 18px;
            }

            button {
                padding: 8px 12px;
                font-size: 12px;
            }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(157, 193, 131, 0.3);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(157, 193, 131, 0.5);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üåø Artificial Terrarium</h1>
    </div>

    <div class="canvas-container">
        <canvas id="canvas" width="850" height="600"></canvas>
        <canvas id="nn-canvas" width="850" height="600"></canvas>
    </div>

    <div class="controls-section">
        <div class="controls-grid">
            <button id="pauseBtn">‚è∏ Pause</button>
            <button id="resetBtn">‚Üª Reset</button>
            <button id="fullscreenBtn">‚õ∂ Toggle NN</button>
        </div>

        <div class="control-group">
            <div class="control-label">
                <span>Speed</span>
                <span id="speedDisplay">30</span>x
            </div>
            <input type="range" id="speedSlider" min="1" max="120" value="30">
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-label">Deer</div>
                <div class="stat-value" id="deerCount">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Wolves</div>
                <div class="stat-value" id="wolfCount">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Plants</div>
                <div class="stat-value" id="plantCount">0</div>
            </div>
            <div class="stat-card day">
                <div class="stat-label">Day</div>
                <div class="stat-value" id="tickCount">0</div>
            </div>
        </div>

        <div id="infoPanel" class="info-panel"></div>
    </div>

    <script>
        // ============================================================================
        // UTILITY FUNCTIONS
        // ============================================================================

        const tools = {
            distance(x1, y1, x2, y2, mw = null, mh = null) {
                if (mw !== null && mh !== null) {
                    x1 = x1 % mw;
                    y1 = y1 % mh;
                    x2 = x2 % mw;
                    y2 = y2 % mh;
                    return ((x2 - x1) % mw) ** 2 + ((y2 - y1) % mh) ** 2;
                }
                return (x2 - x1) ** 2 + (y2 - y1) ** 2;
            },

            clamp(value, minimum, maximum) {
                return Math.max(Math.min(value, maximum), minimum);
            },

            sigmoid(x) {
                x = Math.max(-500, Math.min(500, x));
                return x >= 0 ? 1 / (1 + Math.exp(-x)) : Math.exp(x) / (1 + Math.exp(x));
            },

            softmax(vector) {
                const max = Math.max(...vector);
                const exps = vector.map(v => Math.exp(v - max));
                const sum = exps.reduce((a, b) => a + b, 0);
                return exps.map(exp => exp / sum);
            },

            tanh(x) {
                return Math.tanh(x);
            },

            random(min = 0, max = 1) {
                return Math.random() * (max - min) + min;
            }
        };

        // ============================================================================
        // SPATIAL HASHING GRID
        // ============================================================================

        class SpatialGrid {
            constructor(worldWidth, worldHeight, cellSize = 100) {
                this.worldWidth = worldWidth;
                this.worldHeight = worldHeight;
                this.cellSize = cellSize;
                this.cols = Math.ceil(worldWidth / cellSize);
                this.rows = Math.ceil(worldHeight / cellSize);
                this.grid = Array(this.rows * this.cols).fill(null).map(() => []);
            }

            clear() {
                for (let i = 0; i < this.grid.length; i++) {
                    this.grid[i].length = 0;
                }
            }

            insert(obj) {
                const cellX = Math.floor(obj.x / this.cellSize);
                const cellY = Math.floor(obj.y / this.cellSize);
                const idx = cellY * this.cols + cellX;
                if (idx >= 0 && idx < this.grid.length) {
                    this.grid[idx].push(obj);
                }
            }

            getNeighbors(x, y, radius) {
                const cellX = Math.floor(x / this.cellSize);
                const cellY = Math.floor(y / this.cellSize);
                const radiusCells = Math.ceil(radius / this.cellSize);
                const neighbors = [];

                for (let dy = -radiusCells; dy <= radiusCells; dy++) {
                    for (let dx = -radiusCells; dx <= radiusCells; dx++) {
                        const nx = cellX + dx;
                        const ny = cellY + dy;
                        if (nx >= 0 && nx < this.cols && ny >= 0 && ny < this.rows) {
                            neighbors.push(...this.grid[ny * this.cols + nx]);
                        }
                    }
                }
                return neighbors;
            }
        }

        // ============================================================================
        // NEURAL NETWORK CLASSES
        // ============================================================================

        class Network {
            constructor(layerDims, learningRate = 0.01, momentum = 0.9, weightDecay = 0.0001) {
                this.layerDims = layerDims;
                this.learningRate = learningRate;
                this.momentum = momentum;
                this.weightDecay = weightDecay;
                this.cost = 0.0;
                this.costHistory = [];
                this.output = null;
            }

            xavierInit(inDim, outDim) {
                const limit = Math.sqrt(6.0 / (inDim + outDim));
                const layer = [];
                for (let i = 0; i < inDim; i++) {
                    layer[i] = [];
                    for (let j = 0; j < outDim; j++) {
                        layer[i][j] = tools.random(-limit, limit);
                    }
                }
                return layer;
            }

            matvec(mat, vec) {
                return mat.map(row => row.reduce((sum, val, i) => sum + val * vec[i], 0));
            }

            mapInput(agent) {
                const healthDiff = agent.health - agent.startHealth;
                const xRelative = Math.abs(agent.x - agent.coordsFocused.x) % agent.world.worldWidth / agent.world.worldWidth;
                const yRelative = Math.abs(agent.y - agent.coordsFocused.y) % agent.world.worldHeight / agent.world.worldHeight;
                const sign = agent.priority === "predator" ? -1 : 1;

                this.cost = healthDiff;
                return [xRelative, yRelative, sign, agent.foodNeed, agent.waterNeed, agent.reproductionNeed];
            }

            think(agent) {
                const mappedInput = this.mapInput(agent);
                const values = this.propagate(mappedInput);
                this.output = values.indexOf(Math.max(...values));
                return this.output;
            }

            getAdaptiveLr() {
                if (this.costHistory.length > 0 && this.cost < this.costHistory[this.costHistory.length - 1]) {
                    this.learningRate *= 1.05 * 0.001;
                } else {
                    this.learningRate *= 0.95 * 0.001;
                }

                this.learningRate = Math.max(0.0001, Math.min(0.1, this.learningRate));
                this.costHistory.push(this.cost);
                if (this.costHistory.length > 100) {
                    this.costHistory.shift();
                }
                return this.learningRate;
            }

            propagate(inputs) {
                throw new Error("propagate() must be implemented by subclass");
            }

            adjustWeights() {
                throw new Error("adjustWeights() must be implemented by subclass");
            }
        }

        class DenseNetwork extends Network {
            constructor(animal, learningRate = 0.01, momentum = 0.9, weightDecay = 0.0001) {
                const layerDims = animal.nnLayerDims;
                super(layerDims, learningRate, momentum, weightDecay);

                this.weights = [];
                this.biases = [];
                this.weightVelocity = [];
                this.biasVelocity = [];

                for (let i = 0; i < layerDims.length - 1; i++) {
                    this.weights.push(this.xavierInit(layerDims[i], layerDims[i + 1]));
                    this.biases.push(new Array(layerDims[i + 1]).fill(0));
                    this.weightVelocity.push(this.weights[i].map(row => row.map(() => 0)));
                    this.biasVelocity.push(new Array(layerDims[i + 1]).fill(0));
                }
            }

            propagate(inputs) {
                if (inputs.length !== this.layerDims[0]) {
                    throw new Error("Input size does not match network input layer size");
                }

                let slidingLayer = inputs;

                for (let lIdx = 0; lIdx < this.layerDims.length - 1; lIdx++) {
                    let outLayer = [...this.biases[lIdx]];

                    for (let n1Idx = 0; n1Idx < slidingLayer.length; n1Idx++) {
                        for (let n2Idx = 0; n2Idx < this.layerDims[lIdx + 1]; n2Idx++) {
                            outLayer[n2Idx] += slidingLayer[n1Idx] * this.weights[lIdx][n1Idx][n2Idx];
                        }
                    }

                    if (lIdx < this.layerDims.length - 2) {
                        slidingLayer = outLayer.map(v => tools.sigmoid(v));
                    } else {
                        slidingLayer = outLayer;
                    }
                }

                return tools.softmax(slidingLayer);
            }

            adjustWeights() {
                const normalizedCost = Math.max(-1.0, Math.min(1.0, this.cost));
                const adaptiveLr = this.getAdaptiveLr();

                for (let lIdx = 0; lIdx < this.weights.length; lIdx++) {
                    for (let n1Idx = 0; n1Idx < this.weights[lIdx].length; n1Idx++) {
                        for (let n2Idx = 0; n2Idx < this.weights[lIdx][n1Idx].length; n2Idx++) {
                            const velocity = this.momentum * this.weightVelocity[lIdx][n1Idx][n2Idx] - adaptiveLr * normalizedCost;
                            this.weightVelocity[lIdx][n1Idx][n2Idx] = velocity;
                            this.weights[lIdx][n1Idx][n2Idx] = this.weights[lIdx][n1Idx][n2Idx] * (1 - this.weightDecay) + velocity;
                        }
                    }
                }

                for (let lIdx = 0; lIdx < this.biases.length; lIdx++) {
                    for (let bIdx = 0; bIdx < this.biases[lIdx].length; bIdx++) {
                        const velocity = this.momentum * this.biasVelocity[lIdx][bIdx] - adaptiveLr * 0.1 * normalizedCost;
                        this.biasVelocity[lIdx][bIdx] = velocity;
                        this.biases[lIdx][bIdx] = this.biases[lIdx][bIdx] * (1 - this.weightDecay * 0.1) + velocity;
                    }
                }
            }
        }

        // ============================================================================
        // SPECIES CLASSES
        // ============================================================================

        const SPECIES_CONFIG = {
            deer: {
                sexes: { male: { size: [20, 20] }, female: { size: [20, 20] } },
                mate: 'Deer',
                predators: ['wolf'],
                diet: ['plant'],
                speed: 2.5,
                start_health: 100,
            },
            wolf: {
                sexes: { male: { size: [22, 22] }, female: { size: [22, 22] } },
                mate: 'Wolf',
                predators: [],
                diet: ['deer'],
                speed: 3.5,
                start_health: 120,
            },
            plant: {
                sexes: { asexual: { size: [12, 12] } },
                mate: null,
                predators: [],
                diet: [],
                speed: 0,
                start_health: 5,
            }
        };

        class Coords {
            constructor(x = -1, y = -1) {
                this.x = x;
                this.y = y;
            }
        }

        class Living {
            constructor(world, coord) {
                this.world = world;
                this.birthCoord = coord;
                this.tob = Date.now();
                this.generation = 0;
                this.alive = true;
                this.x = coord[0];
                this.y = coord[1];
            }

            generateEntity(speciesType, sexesInfo) {
                const sexKeys = Object.keys(sexesInfo);
                this.sex = sexKeys[Math.floor(Math.random() * sexKeys.length)];
                const sizeData = sexesInfo[this.sex].size;
                this.width = sizeData[0] * this.world.proportion;
                this.height = sizeData[1] * this.world.proportion;
                this.species = speciesType;
            }

            attacked(predator) {
                const healthDepl = this.startHealth * 0.1;
                this.health -= healthDepl;
                this.check();
                
                if (this instanceof Animal && predator instanceof Animal && !this.alive) {
                    predator.health += this.startHealth;
                    predator.foodNeed -= this.startHealth;
                } else if (this instanceof Plant && predator instanceof Animal) {
                    predator.health += healthDepl;
                    predator.foodNeed -= healthDepl;
                }
            }

            check() {
                if (this.health <= 1) {
                    this.die();
                }
            }

            die() {
                this.alive = false;
            }
        }

        class Animal extends Living {
            constructor(world, coord, speciesType) {
                super(world, coord);
                this.speciesType = speciesType;
                const speciesInfo = SPECIES_CONFIG[speciesType];
                this.sexesInfo = speciesInfo.sexes;
                this.diet = speciesInfo.diet;
                this.predators = speciesInfo.predators;
                this.matePreference = speciesInfo.mate;
                this.speed = speciesInfo.speed;
                this.startHealth = speciesInfo.start_health;
                
                this.generateEntity(speciesType, this.sexesInfo);
                
                this.memory = { predator: null, food: null, water: null, mate: null };
                this.priorityDict = {};
                this.priority = null;
                this.health = this.startHealth;
                this.ageDepl = this.startHealth * 0.00002;
                this.waterDepl = this.startHealth * 0.001;
                this.foodDepl = this.startHealth * 0.001;
                this.waterNeed = Math.random() * 0.02 + 0.01;
                this.foodNeed = Math.random() * 0.02 + 0.01;
                this.reproductionNeed = Math.random() * 0.02 + 0.01;
                this.avoidNeed = 0;
                this.foodIncrement = this.health * 0.0003;
                this.waterIncrement = this.health * 0.0001;
                this.reproductionIncrement = this.health * 0.0005;
                this.lastChildTob = Date.now();
                this.childGracePeriod = Math.floor(Math.random() * 15 + 15) * 1000;
                this.lookForMate = false;
                this.visionDist = Math.random() * 85 + 15;
                this.mutationMulti = 0.5;
                this.probMutation = 0.1;
                this.coordsFocused = new Coords(this.x, this.y);
                this.isPlayer = false;
                this.outputIdx = 0;
                this.brainUpdateCounter = 0;

                this.coordChanges = [
                    [this.speed, 0], [-this.speed, 0], [0, this.speed], [0, -this.speed],
                    [this.speed, this.speed], [this.speed, -this.speed],
                    [-this.speed, this.speed], [-this.speed, -this.speed]
                ];
                this.numInputs = 6;
                this.nnLayerDims = [
                    this.numInputs, this.numInputs, 9, this.coordChanges.length, this.coordChanges.length
                ];

                this.brain = new DenseNetwork(this);
                this.output = null;
            }

            find(objects) {
                return objects.filter(obj => {
                    if (!(obj instanceof Animal)) return false;
                    const dist = tools.distance(this.x, this.y, obj.x, obj.y);
                    return dist <= this.visionDist ** 2 && obj !== this;
                });
            }

            focus(target, type) {
                this.memory[type] = [target.x, target.y];
            }

            locate(spatialGrid) {
                const candidates = spatialGrid.getNeighbors(this.x, this.y, this.visionDist);
                const objDistances = { predator: Infinity, food: Infinity, water: Infinity, mate: Infinity };

                for (let obj of candidates) {
                    if (!(obj instanceof Animal) || obj === this) continue;
                    const objDist = tools.distance(this.x, this.y, obj.x, obj.y);
                    const inSight = objDist <= this.visionDist ** 2;

                    if (!inSight) continue;

                    if (this.predators.length > 0 && this.predators.includes(obj.speciesType)) {
                        if (objDist < objDistances.predator) {
                            objDistances.predator = objDist;
                            this.focus(obj, "predator");
                            this.avoidNeed = 0.5;
                        }
                    } else if (this.diet.includes(obj.speciesType) && objDist < objDistances.food) {
                        objDistances.food = objDist;
                        this.focus(obj, "food");
                    } else if (obj.speciesType === this.matePreference && obj.sex !== this.sex && objDist < objDistances.mate) {
                        objDistances.mate = objDist;
                        this.focus(obj, "mate");
                    }
                }

                for (let obj of this.world.world) {
                    if (obj instanceof Water) {
                        const objDist = tools.distance(this.x, this.y, obj.x, obj.y);
                        if (objDist < objDistances.water) {
                            objDistances.water = objDist;
                            this.focus(obj, "water");
                        }
                    }
                }
            }

            think(spatialGrid) {
                if (!this.isPlayer) {
                    this.locate(spatialGrid);
                    const needs = {
                        predator: this.avoidNeed,
                        food: this.foodNeed,
                        water: this.waterNeed,
                        mate: this.reproductionNeed
                    };

                    const priorityList = Object.entries(needs).sort((a, b) => b[1] - a[1]);
                    this.priorityDict = Object.fromEntries(priorityList);

                    for (let [need, _] of priorityList) {
                        const needLocation = this.memory[need];
                        if (needLocation !== null) {
                            this.priority = need;
                            this.coordsFocused.x = needLocation[0];
                            this.coordsFocused.y = needLocation[1];
                            break;
                        }
                    }

                    const agentsChoice = this.brain.think(this);
                    this.outputIdx = agentsChoice;
                    this.move();
                }
            }

            move() {
                const coordChange = this.coordChanges[this.outputIdx];
                this.x = (coordChange[0] + this.x) % this.world.worldWidth;
                this.y = (coordChange[1] + this.y) % this.world.worldHeight;
            }

            updateResourcesNeed() {
                this.waterNeed += this.waterIncrement;
                this.foodNeed += this.foodIncrement;
                if (this.lookForMate) {
                    this.reproductionNeed += this.reproductionIncrement;
                }
            }

            updateInternalClocks() {
                this.lookForMate = (Date.now() - this.lastChildTob) >= this.childGracePeriod;
            }

            updateMemory() {
                for (let key of Object.keys(this.memory)) {
                    const loc = this.memory[key];
                    if (loc !== null && tools.distance(this.x, this.y, loc[0], loc[1]) > this.visionDist ** 2) {
                        this.memory[key] = null;
                    }
                }
            }

            updateBody(environment, worldObjs) {
                this.updateResourcesNeed();
                this.updateInternalClocks();
                this.updateMemory();
                const elapsedTime = (Date.now() - this.tob) / 1000;
                this.health -= elapsedTime * this.ageDepl;
                this.health -= this.waterNeed * 0.0001;
                this.health -= this.foodNeed * 0.0001;
                this.avoidNeed = 0;
                this.detectCollision(environment, worldObjs);
                this.check();
            }

            update(environment, worldObjs, spatialGrid) {
                this.updateBody(environment, worldObjs);
                this.brainUpdateCounter++;
                if (this.brainUpdateCounter >= 1) {
                    this.brain.adjustWeights();
                    this.brainUpdateCounter = 0;
                }
                this.think(spatialGrid);
            }

            detectCollision(environment, worldObjs) {
                for (let obj of worldObjs) {
                    if (!(obj instanceof Animal)) continue;
                    const dist = tools.distance(this.x, this.y, obj.x, obj.y);
                    if (dist > 850) continue;

                    if (this.lookForMate && this.sex === "female" && obj.speciesType === this.matePreference && 
                        obj.sex === "male" && obj !== this) {
                        const child = this.mate(obj);
                        environment.children.push(child);
                        return;
                    }

                    if (this.diet.includes(obj.speciesType)) {
                        obj.attacked(this);
                    }
                }

                for (let obj of worldObjs) {
                    if (obj instanceof Water) {
                        const dist = tools.distance(this.x, this.y, obj.x, obj.y);
                        if (dist <= 850) {
                            this.waterNeed -= this.waterIncrement;
                        }
                    }
                }
            }

            mate(parent2) {
                const childClass = this.speciesType === "deer" ? Deer : Wolf;
                const child = new childClass(this.world, [this.x, this.y - (this.width + 5)]);
                
                const lowerBound = Math.max(1 - this.mutationMulti, 0.1);
                const upperBound = Math.min(1 + this.mutationMulti, 4.0);
                
                child.speed = ((this.speed + parent2.speed) / 2) * tools.random(lowerBound, upperBound);
                child.coordChanges = [
                    [child.speed, 0], [-child.speed, 0], [0, child.speed], [0, -child.speed],
                    [child.speed, child.speed], [child.speed, -child.speed],
                    [-child.speed, child.speed], [-child.speed, -child.speed]
                ];
                child.visionDist = ((this.visionDist + parent2.visionDist) / 2) * tools.random(lowerBound, upperBound);
                child.mutationMulti = ((this.mutationMulti + parent2.mutationMulti) / 2) * tools.random(0.9, 1.1);
                child.brain = new DenseNetwork(child);
                child.brain.learningRate = ((this.brain.learningRate + parent2.brain.learningRate) / 2) * tools.random(0.5, 1.5);

                this.lastChildTob = Date.now();
                this.updateInternalClocks();
                this.reproductionNeed = 0;
                this.generation = Math.max(this.generation, parent2.generation) + 1;

                parent2.lastChildTob = Date.now();
                parent2.updateInternalClocks();
                parent2.reproductionNeed = 0;

                return child;
            }
        }

        class Deer extends Animal {
            constructor(world, coord) {
                super(world, coord, "deer");
            }
        }

        class Wolf extends Animal {
            constructor(world, coord) {
                super(world, coord, "wolf");
            }
        }

        class Plant extends Living {
            constructor(world, coord) {
                super(world, coord);
                const speciesInfo = SPECIES_CONFIG.plant;
                this.sexesInfo = speciesInfo.sexes;
                this.generateEntity("plant", this.sexesInfo);
                this.health = 5;
                this.startHealth = this.health;
            }

            update() {
                this.check();
            }
        }

        class Water {
            constructor(coord, proportion) {
                this.x = coord[0];
                this.y = coord[1];
                this.size = 20;
                this.alive = true;
                this.width = this.size;
                this.height = this.size;
            }
        }

        // ============================================================================
        // ENVIRONMENT CLASS
        // ============================================================================

        class Environment {
            constructor(worldSize, proportion = 0.1) {
                this.worldWidth = worldSize[0];
                this.worldHeight = worldSize[1];
                this.proportion = proportion;
                this.wNumChunks = 50;
                this.hNumChunks = 50;
                this.wChunkSize = Math.ceil(this.worldWidth / this.wNumChunks);
                this.hChunkSize = Math.ceil(this.worldHeight / this.hNumChunks);
                this.children = [];
                this.unwalkable = [];
                this.soil = [];
                this.terrainColor = [];
                this.world = [];
                this.spatialGrid = new SpatialGrid(worldSize[0], worldSize[1], 100);
            }

            generateWorld(speciesTypes, bodiesOfWater = 5, waterBodySize = "Large") {
                const water = this.generateTerrain(bodiesOfWater, waterBodySize);
                const living = this.generateLiving(speciesTypes);
                this.world = water.concat(living);
                return this.world;
            }

            generateTerrain(bodiesOfWater, waterBodySize) {
                this.generateWater(bodiesOfWater, waterBodySize);
                const water = this.unwalkable;
                this.generateLand();
                return water;
            }

            generateLiving(speciesTypes) {
                const plants = [];
                const animals = [];

                for (let i = 0; i < speciesTypes.plants; i++) {
                    plants.push(this.generatePlant());
                }
                for (let i = 0; i < speciesTypes.deer; i++) {
                    animals.push(new Deer(this, [
                        Math.random() * this.worldWidth,
                        Math.random() * this.worldHeight
                    ]));
                }
                for (let i = 0; i < speciesTypes.wolves; i++) {
                    animals.push(new Wolf(this, [
                        Math.random() * this.worldWidth,
                        Math.random() * this.worldHeight
                    ]));
                }

                return plants.concat(animals);
            }

            generateWater(bodiesOfWater, waterBodySize) {
                for (let w = 0; w < bodiesOfWater; w++) {
                    const bodySize = waterBodySize !== "Large" ? 
                        Math.floor(Math.random() * 100 + 100) : 
                        Math.floor(Math.random() * 100 + 850);
                    this.generateVein(bodySize);
                }
            }

            generateVein(counter) {
                let x = Math.random() * this.worldWidth * 0.75;
                let y = Math.random() * this.worldHeight * 0.75;

                for (let step = 0; step < counter; step++) {
                    const water = new Water([x, y], this.proportion);
                    this.unwalkable.push(water);

                    const options = [1, 2, 3];
                    const choice = options[Math.floor(Math.random() * options.length)];
                    const walkSize = water.size;
                    const walkOptions = {
                        0: [0, walkSize], 1: [0, -walkSize],
                        2: [walkSize, 0], 3: [-walkSize, 0]
                    };
                    const [dx, dy] = walkOptions[choice];
                    x = (x + dx) % this.worldWidth;
                    y = (y + dy) % this.worldHeight;
                }
            }

            generateLand() {
                for (let row = 0; row < this.wNumChunks; row++) {
                    for (let col = 0; col < this.hNumChunks; col++) {
                        const hasWater = this.unwalkable.some(w =>
                            Math.abs(this.wChunkSize * row - w.x) < 100 &&
                            Math.abs(this.hChunkSize * col - w.y) < 100
                        );

                        if (hasWater) {
                            this.terrainColor.push([
                                Math.floor(Math.random() * 40 + 200),
                                Math.floor(Math.random() * 20 + 170),
                                Math.floor(Math.random() * 20 + 150)
                            ]);
                        } else {
                            this.terrainColor.push([
                                Math.floor(Math.random() * 15 + 75),
                                Math.floor(Math.random() * 10 + 110),
                                Math.floor(Math.random() * 10 + 40)
                            ]);
                        }
                    }
                }
            }

            generatePlant() {
                const coord = [Math.random() * this.worldWidth, Math.random() * this.worldHeight];
                return new Plant(this, coord);
            }

            update(worldObjs) {
                this.spatialGrid.clear();
                for (let obj of worldObjs) {
                    if (obj instanceof Animal) {
                        this.spatialGrid.insert(obj);
                    }
                }

                for (let obj of worldObjs) {
                    if (obj instanceof Animal) {
                        if (obj.isPlayer) {
                            obj.updateBody(this, worldObjs);
                        } else {
                            obj.update(this, worldObjs, this.spatialGrid);
                        }
                    } else if (obj instanceof Plant) {
                        obj.update();
                    }
                }

                if (Math.random() <= 0.15) {
                    worldObjs.push(this.generatePlant());
                }

                worldObjs = worldObjs.filter(obj => obj.alive);
                worldObjs.push(...this.children);
                this.children = [];
                return worldObjs;
            }
        }

        // ============================================================================
        // NNVisualizer CLASS
        // ============================================================================

        class NNVisualizer {
            constructor(canvasElement, screenSize) {
                this.canvas = canvasElement;
                this.ctx = this.canvas.getContext('2d');
                this.w_width = screenSize[0];
                this.w_height = screenSize[1];
                this.node_size = 15;
                this.scale = 0.75;
                this.fontSizeBase = 30;
            }

            draw(animal) {
                const nn = animal.brain;
                const markedNodeIdx = animal.outputIdx;

                // Clear with transparency instead of filling background
                this.ctx.clearRect(0, 0, this.w_width, this.w_height);

                this.drawLabel(nn);

                const allNodesPos = this.drawNodes(nn, markedNodeIdx);
                const weights = this.extractWeights(nn);
                
                if (weights.length > 0) {
                    const [minWeight, maxWeight] = this.getWeightRange(weights);
                    this.drawEdges(allNodesPos, weights, minWeight, maxWeight);
                }
            }

            drawLabel(nn) {
                const networkLabel = this.getNetworkLabel(nn);
                const label = `${networkLabel}`;
                
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                this.ctx.font = `${Math.floor(this.fontSizeBase * this.scale)}px Arial`;
                this.ctx.textAlign = 'center';
                
                const lines = label.split('\n');
                lines.forEach((line, idx) => {
                    this.ctx.fillText(line, this.w_width / 2, 30 + idx * 25);
                });
            }

            getNetworkLabel(nn) {
                if (nn.weights && nn.weights.length > 0 && typeof nn.weights[0] === 'object') {
                    if (nn.weights[0].W_i !== undefined) {
                        return 'LSTMNetwork';
                    }
                }
                return 'DenseNetwork';
            }

            drawNodes(nn, markedNodeIdx) {
                const layerDims = this.getLayerDims(nn);
                const w_stride = this.w_width * 0.1;
                const h_stride = this.w_height * 0.055;
                this.node_size = this.w_height * 0.0175 * 0.5;
                const nn_len = layerDims.length;
                const allNodesPos = [];

                for (let l_idx = 0; l_idx < nn_len; l_idx++) {
                    const l_nodes_pos = [];
                    const num_nodes = layerDims[l_idx];

                    for (let n_idx = 0; n_idx < num_nodes; n_idx++) {
                        const adjust = (num_nodes * h_stride) / 2;
                        const x = this.w_width * 0.25 + l_idx * w_stride;
                        const y = this.w_height * 0.25 - adjust + n_idx * h_stride + 70;

                        let nodeColor = 'rgba(255, 255, 255, 0.7)';
                        if (l_idx === nn_len - 1 && n_idx === markedNodeIdx) {
                            nodeColor = 'rgba(255, 0, 0, 1)';
                        }

                        this.ctx.strokeStyle = nodeColor;
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, this.node_size * this.scale, 0, 2 * Math.PI);
                        this.ctx.stroke();

                        l_nodes_pos.push([x, y]);
                    }
                    allNodesPos.push(l_nodes_pos);
                }

                return allNodesPos;
            }

            drawEdges(allNodesPos, weights, minWeight, maxWeight) {
                for (let l_idx = 0; l_idx < allNodesPos.length - 1; l_idx++) {
                    for (let n1_idx = 0; n1_idx < allNodesPos[l_idx].length; n1_idx++) {
                        for (let n2_idx = 0; n2_idx < allNodesPos[l_idx + 1].length; n2_idx++) {
                            const weight = weights[l_idx][n1_idx][n2_idx];

                            const threshold = minWeight + (maxWeight - minWeight) * 0.1;
                            if (weight < threshold) {
                                continue;
                            }

                            const currentNodePos = allNodesPos[l_idx][n1_idx];
                            const nextNodePos = allNodesPos[l_idx + 1][n2_idx];

                            const scaledWeight =
                                maxWeight !== minWeight
                                    ? (weight - minWeight) / (maxWeight - minWeight)
                                    : 0.5;

                            const lineColor = this.getWeightColor(weight, scaledWeight);
                            const width = 1;

                            this.ctx.strokeStyle = lineColor;
                            this.ctx.lineWidth = width;
                            this.ctx.beginPath();
                            this.ctx.moveTo(
                                currentNodePos[0] + this.node_size,
                                currentNodePos[1]
                            );
                            this.ctx.lineTo(
                                nextNodePos[0] - this.node_size,
                                nextNodePos[1]
                            );
                            this.ctx.stroke();
                        }
                    }
                }
            }

            extractWeights(nn) {
                if (!nn.weights) {
                    return [];
                }

                if (Array.isArray(nn.weights) && nn.weights.length > 0) {
                    const firstLayer = nn.weights[0];

                    if (firstLayer && typeof firstLayer === 'object' && firstLayer.W_i !== undefined) {
                        return this.extractLSTMWeights(nn);
                    }

                    return nn.weights;
                }

                return [];
            }

            extractLSTMWeights(nn) {
                const combined = [];

                if (nn.weights && Array.isArray(nn.weights)) {
                    for (let lstm_layer of nn.weights) {
                        const W_i = lstm_layer.W_i || [];
                        const W_f = lstm_layer.W_f || [];
                        const W_c = lstm_layer.W_c || [];
                        const W_o = lstm_layer.W_o || [];

                        const avgWeight = this.averageMatrices([W_i, W_f, W_c, W_o]);
                        combined.push(avgWeight);
                    }
                }

                if (nn.V) {
                    combined.push(nn.V);
                }

                return combined;
            }

            averageMatrices(matrices) {
                if (matrices.length === 0) return [];
                if (matrices[0].length === 0) return [];

                const rows = matrices[0].length;
                const cols = matrices[0][0].length;
                const result = Array(rows).fill(null).map(() => Array(cols).fill(0));

                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        let sum = 0;
                        for (let mat of matrices) {
                            if (mat[i] && mat[i][j] !== undefined) {
                                sum += mat[i][j];
                            }
                        }
                        result[i][j] = sum / matrices.length;
                    }
                }

                return result;
            }

            getLayerDims(nn) {
                if (nn.layerDims) {
                    return nn.layerDims;
                }
                if (nn.layer_dims) {
                    return nn.layer_dims;
                }

                const dims = [];
                if (nn.weights && Array.isArray(nn.weights)) {
                    dims.push(nn.weights[0].length);
                    for (let layer of nn.weights) {
                        if (layer[0]) {
                            dims.push(layer[0].length);
                        }
                    }
                }

                return dims.length > 0 ? dims : [6, 6, 9, 8, 8];
            }

            getWeightRange(weights) {
                let min = Infinity;
                let max = -Infinity;

                for (let layer of weights) {
                    for (let row of layer) {
                        for (let w of row) {
                            if (w < min) min = w;
                            if (w > max) max = w;
                        }
                    }
                }

                return [min === Infinity ? -1 : min, max === -Infinity ? 1 : max];
            }

            getWeightColor(weight, maxAbsWeight = 1.0) {
                if (maxAbsWeight === 0) {
                    maxAbsWeight = 1.0;
                }

                let normalized = weight / maxAbsWeight;
                normalized = Math.max(-1.0, Math.min(1.0, normalized));

                let r, g, b;

                if (normalized < 0) {
                    r = 255;
                    g = Math.floor(255 * (1 + normalized));
                    b = Math.floor(255 * (1 + normalized));
                } else {
                    r = Math.floor(255 * (1 - normalized));
                    g = Math.floor(255 * (1 - normalized));
                    b = 255;
                }

                const isGrayish =
                    Math.abs(r - g) < 20 &&
                    Math.abs(g - b) < 20 &&
                    Math.abs(r - b) < 20;
                const alpha = isGrayish ? 0.3 : 0.7;

                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }

            resize(screenSize) {
                this.w_width = screenSize[0];
                this.w_height = screenSize[1];
                this.canvas.width = this.w_width;
                this.canvas.height = this.w_height;
            }
        }

        // ============================================================================
        // SIMULATION STATE & LOGIC
        // ============================================================================

        const WORLD_WIDTH = 850;
        const WORLD_HEIGHT = 600;

        let environment = null;
        let world = null;
        let paused = false;
        let speed = 30;
        let selectedObj = null;
        let ticks = 0;
        let animationId = null;
        let showNN = false;

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const nnCanvas = document.getElementById('nn-canvas');
        const pauseBtn = document.getElementById('pauseBtn');
        const resetBtn = document.getElementById('resetBtn');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const speedSlider = document.getElementById('speedSlider');
        const speedDisplay = document.getElementById('speedDisplay');
        const infoPanel = document.getElementById('infoPanel');
        const deerCount = document.getElementById('deerCount');
        const wolfCount = document.getElementById('wolfCount');
        const plantCount = document.getElementById('plantCount');
        const tickCount = document.getElementById('tickCount');

        const visualizer = new NNVisualizer(nnCanvas, [850, 600]);

        // Initialize
        function init() {
            environment = new Environment([WORLD_WIDTH, WORLD_HEIGHT], 0.15);
            world = environment.generateWorld(
                { plants: 50, deer: 100, wolves: 15 },
                5,
                "Large"
            );
            updateStats();
            draw();
        }

        // Update stats display
        function updateStats() {
            const deer = world.filter(o => o instanceof Deer).length;
            const wolves = world.filter(o => o instanceof Wolf).length;
            const plants = world.filter(o => o instanceof Plant).length;
            
            deerCount.textContent = deer;
            wolfCount.textContent = wolves;
            plantCount.textContent = plants;
            tickCount.textContent = Math.round(ticks / (24 * 60) * 100, 3) / 100;
        }

        // Draw the simulation
        function draw() {
            ctx.clearRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

            // Draw terrain
            let index = 0;
            for (let row = 0; row < environment.wNumChunks; row++) {
                for (let col = 0; col < environment.hNumChunks; col++) {
                    const color = environment.terrainColor[index] || [100, 100, 100];
                    ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                    ctx.fillRect(
                        environment.wChunkSize * row,
                        environment.hChunkSize * col,
                        environment.wChunkSize,
                        environment.hChunkSize
                    );
                    index++;
                }
            }

            // Draw objects
            for (let obj of world) {
                if (obj instanceof Water) {
                    ctx.fillStyle = '#2865c9';
                    ctx.fillRect(obj.x - obj.size / 2, obj.y - obj.size / 2, obj.size, obj.size);
                } else if (obj instanceof Plant) {
                    ctx.fillStyle = '#228b22';
                    ctx.beginPath();
                    ctx.arc(obj.x, obj.y, obj.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (obj instanceof Deer) {
                    ctx.fillStyle = `rgb(135, 206, 250)`;
                    ctx.fillRect(obj.x - obj.width / 2, obj.y - obj.height / 2, obj.width, obj.height);
                    if (obj.isPlayer) {
                        ctx.strokeStyle = '#ffff00';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(obj.x - obj.width / 2 - 2, obj.y - obj.height / 2 - 2, obj.width + 4, obj.height + 4);
                    }
                } else if (obj instanceof Wolf) {
                    ctx.fillStyle = `rgb(255, 215, 0)`;
                    ctx.beginPath();
                    const points = [
                        [obj.x, obj.y - obj.width / 2],
                        [obj.x + obj.width / 2, obj.y],
                        [obj.x, obj.y + obj.width / 2],
                        [obj.x - obj.width / 2, obj.y]
                    ];
                    ctx.moveTo(points[0][0], points[0][1]);
                    for (let p of points.slice(1)) ctx.lineTo(p[0], p[1]);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            // Draw vision circle if selected
            if (selectedObj && selectedObj instanceof Animal) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(selectedObj.x, selectedObj.y, selectedObj.visionDist, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        // Update simulation
        function update() {
            if (!paused) {
                world = environment.update(world);
                ticks++;
                updateStats();
            }
            draw();
            
            if (selectedObj && selectedObj.alive && selectedObj instanceof Animal && selectedObj.brain && selectedObj.brain.weights) {
                visualizer.draw(selectedObj);
            }
        }

        // Event listeners
        pauseBtn.addEventListener('click', () => {
            paused = !paused;
            pauseBtn.textContent = paused ? '‚ñ∂ Resume' : '‚è∏ Pause';
            pauseBtn.classList.toggle('paused');
        });

        resetBtn.addEventListener('click', () => {
            init();
            paused = false;
            pauseBtn.textContent = '‚è∏ Pause';
            pauseBtn.classList.remove('paused');
            selectedObj = null;
            infoPanel.classList.remove('visible');
        });

        fullscreenBtn.addEventListener('click', () => {
            showNN = !showNN;
            nnCanvas.classList.toggle('visible');
        });

        speedSlider.addEventListener('change', (e) => {
            speed = Number(e.target.value);
            speedDisplay.textContent = speed;
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            let closest = null;
            let closestDist = Infinity;

            for (let obj of world) {
                const objLeft = obj.x - obj.width / 2;
                const objRight = obj.x + obj.width / 2;
                const objTop = obj.y - obj.height / 2;
                const objBottom = obj.y + obj.height / 2;

                if (x >= objLeft && x <= objRight && y >= objTop && y <= objBottom) {
                    const dist = Math.sqrt((obj.x - x) ** 2 + (obj.y - y) ** 2);
                    if (dist < closestDist) {
                        closest = obj;
                        closestDist = dist;
                    }
                } else {
                    const dist = Math.sqrt((obj.x - x) ** 2 + (obj.y - y) ** 2);
                    if (dist < closestDist && dist < 30) {
                        closest = obj;
                        closestDist = dist;
                    }
                }
            }

            selectedObj = closest;
            displayInfo();
        });

        // Display selected object info
        function displayInfo() {
            return;
            if (!selectedObj) {
                infoPanel.classList.remove('visible');
                return;
            }

            let html = `<strong>üìä ${selectedObj.species}</strong>`;

            if (selectedObj instanceof Animal) {
                html += `<p>Health: ${selectedObj.health.toFixed(1)}/${selectedObj.startHealth}</p>
                    <p>Gen: ${selectedObj.generation} | Speed: ${selectedObj.speed.toFixed(1)}</p>
                    <p>Vision: ${selectedObj.visionDist.toFixed(0)} | Pos: (${selectedObj.x.toFixed(0)}, ${selectedObj.y.toFixed(0)})</p>
                    <p>Hunger: ${selectedObj.foodNeed.toFixed(2)} | Thirst: ${selectedObj.waterNeed.toFixed(2)}</p>`;
                
                if (selectedObj.brain && selectedObj.brain.weights) {
                    visualizer.draw(selectedObj);
                }
            } else if (selectedObj instanceof Plant) {
                html += `<p>Health: ${selectedObj.health}</p>`;
            }

            infoPanel.innerHTML = html;
            infoPanel.classList.add('visible');
        }

        // Main loop
        function mainLoop() {
            update();
            const interval = 1000 / speed;
            setTimeout(mainLoop, interval);
        }

        // Start simulation
        init();
        mainLoop();

        // Handle responsive canvas resize
        window.addEventListener('resize', () => {
        });

        // hi. ok. bye.
    </script>
</body>
</html>