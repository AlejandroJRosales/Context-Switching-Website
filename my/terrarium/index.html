<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Artificial Terrarium</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            height: 100dvh;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Neural Network Visualizer */
        #nnVisualizerContainer {
            position: absolute;
            top: max(50px, calc(env(safe-area-inset-top) + 40px));
            right: max(10px, env(safe-area-inset-right));
            width: clamp(200px, 25vw, 400px);
            height: clamp(200px, 25vw, 400px);
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #00ff00;
            border-radius: 4px;
            padding: 10px;
            display: none;
            flex-direction: column;
            z-index: 15;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        #nnVisualizerContainer.show {
            display: flex;
        }

        #nnCanvasWrapper {
            flex: 1;
            position: relative;
            background: #000;
            border: 1px solid rgba(0, 255, 0, 0.3);
            border-radius: 2px;
            overflow: hidden;
        }

        #nnCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #nnLabel {
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            margin-top: 5px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* HUD Elements */
        .hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            font-family: 'Courier New', monospace;
            color: #00ff00;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            font-size: clamp(10px, 2.5vw, 16px);
        }

        .hud-header {
            position: absolute;
            top: max(10px, env(safe-area-inset-top));
            left: max(10px, env(safe-area-inset-left));
            font-size: clamp(14px, 3vw, 18px);
            font-weight: bold;
            letter-spacing: 1px;
            text-transform: uppercase;
            z-index: 10;
        }

        .hud-stats {
            position: absolute;
            top: max(50px, calc(env(safe-area-inset-top) + 40px));
            left: max(10px, env(safe-area-inset-left));
            font-size: clamp(10px, 2vw, 14px);
            line-height: 1.6;
            background: rgba(0, 0, 0, 0.7);
            padding: clamp(8px, 2vw, 15px);
            border: 1px solid #00ff00;
            border-radius: 4px;
            max-width: 90vw;
            animation: pulse 2s infinite;
        }

        .hud-controls {
            position: absolute;
            bottom: max(80px, calc(env(safe-area-inset-bottom) + 70px));
            left: max(10px, env(safe-area-inset-left));
            font-size: clamp(9px, 1.8vw, 12px);
            background: rgba(0, 0, 0, 0.7);
            padding: clamp(8px, 2vw, 15px);
            border: 1px solid #00ff00;
            border-radius: 4px;
            max-width: 90vw;
            line-height: 1.5;
            display: none;
        }

        .hud-controls.show {
            display: block;
        }

        .hud-crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            border: 2px solid #00ff00;
            border-radius: 50%;
            opacity: 0.4;
            pointer-events: none;
        }

        .hud-crosshair::before,
        .hud-crosshair::after {
            content: '';
            position: absolute;
            background: #00ff00;
        }

        .hud-crosshair::before {
            width: 10px;
            height: 2px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .hud-crosshair::after {
            width: 2px;
            height: 10px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .hud-target-info {
            position: absolute;
            top: max(10px, env(safe-area-inset-top));
            right: max(10px, env(safe-area-inset-right));
            font-size: clamp(10px, 2vw, 14px);
            background: rgba(0, 0, 0, 0.7);
            padding: clamp(8px, 2vw, 15px);
            border: 1px solid #00ff00;
            border-radius: 4px;
            min-width: 150px;
            text-align: right;
            display: none;
            z-index: 10;
        }

        .hud-target-info.visible {
            display: block;
        }

        .fps-counter {
            position: absolute;
            bottom: max(10px, env(safe-area-inset-bottom));
            right: max(10px, env(safe-area-inset-right));
            font-size: clamp(9px, 2vw, 12px);
            color: #00ff00;
            background: rgba(0, 0, 0, 0.7);
            padding: clamp(8px, 1.5vw, 10px);
            border: 1px solid #00ff00;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            z-index: 10;
        }

        .speed-indicator {
            position: absolute;
            bottom: max(10px, env(safe-area-inset-bottom));
            left: max(10px, env(safe-area-inset-left));
            font-size: clamp(9px, 2vw, 12px);
            background: rgba(0, 0, 0, 0.7);
            padding: clamp(8px, 1.5vw, 12px);
            border: 1px solid #00ff00;
            border-radius: 4px;
            min-width: 120px;
            display: none;
        }

        .speed-indicator.show {
            display: block;
        }

        /* Control Buttons */
        .control-panel {
            position: absolute;
            bottom: max(10px, env(safe-area-inset-bottom));
            right: max(10px, env(safe-area-inset-right));
            display: flex;
            gap: 10px;
            pointer-events: auto;
            flex-wrap: wrap;
            justify-content: flex-end;
            max-width: 90vw;
        }

        button {
            padding: clamp(8px, 2vw, 12px) clamp(12px, 3vw, 20px);
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            border: 1px solid #00ff00;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: clamp(9px, 2vw, 12px);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.2s;
            pointer-events: auto;
            touch-action: manipulation;
            -webkit-appearance: none;
            appearance: none;
        }

        button:hover, button:active {
            background: rgba(0, 255, 0, 0.1);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        button:active {
            transform: scale(0.95);
        }

        /* Touch Joystick */
        .joystick-container {
            position: absolute;
            bottom: max(20px, calc(env(safe-area-inset-bottom) + 10px));
            left: max(20px, env(safe-area-inset-left));
            width: clamp(80px, 20vw, 120px);
            height: clamp(80px, 20vw, 120px);
            background: rgba(0, 255, 0, 0.1);
            border: 2px solid rgba(0, 255, 0, 0.3);
            border-radius: 50%;
            pointer-events: auto;
            touch-action: none;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .joystick-container.show {
            display: flex;
        }

        .joystick-knob {
            width: clamp(30px, 8vw, 50px);
            height: clamp(30px, 8vw, 50px);
            background: rgba(0, 255, 0, 0.6);
            border: 2px solid #00ff00;
            border-radius: 50%;
            position: absolute;
            touch-action: none;
        }

        /* Scanline effect */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.03),
                rgba(0, 0, 0, 0.03) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 100;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            .hud-header {
                font-size: clamp(12px, 4vw, 16px);
            }

            .hud-stats {
                font-size: clamp(9px, 2.5vw, 12px);
            }

            .control-panel {
                bottom: max(100px, calc(env(safe-area-inset-bottom) + 90px));
            }

            #nnVisualizerContainer {
                width: clamp(150px, 35vw, 300px);
                height: clamp(150px, 35vw, 300px);
            }
        }

        @media (orientation: landscape) {
            .hud-controls {
                display: none !important;
            }

            .joystick-container {
                width: clamp(60px, 15vw, 100px);
                height: clamp(60px, 15vw, 100px);
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="hud">
        <div class="hud-header">üåøTERRARIUM</div>

        <div class="hud-stats">
            <div>ü¶å <span id="deerCount">0</span> | üê∫ <span id="wolfCount">0</span></div>
            <div>üå± <span id="plantCount">0</span> | Day <span id="dayCount">0</span></div>
        </div>

        <div class="hud-controls">
            <div>CONTROLS</div>
            <div>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</div>
            <div>Drag joystick to move</div>
            <div>Tilt device to look</div>
            <div>Tap entity to track</div>
        </div>

        <div class="hud-target-info" id="targetInfo">
            <div id="targetName">-</div>
            <div id="targetStats">-</div>
        </div>

        <div id="nnVisualizerContainer">
            <div id="nnCanvasWrapper">
                <canvas id="nnCanvas"></canvas>
            </div>
            <div id="nnLabel">No Target</div>
        </div>

        <div class="fps-counter" id="fpsCounter">FPS: 60</div>

        <div class="speed-indicator show" id="speedIndicator">
            <div>SPEED</div>
            <div id="speedValue">0.0</div>
        </div>

        <div class="hud-crosshair"></div>
        <div class="scanlines"></div>
    </div>

    <div class="joystick-container show" id="joystick"></div>

    <div class="control-panel">
        <button id="controlBtn">Keyboard</button>
        <button id="nnVisBtn">Show NN</button>
        <button id="resetBtn">Reset</button>
        <button id="helpBtn">Help</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ============================================================================
        // NEURAL NETWORK VISUALIZER CLASS
        // ============================================================================

        class NNVisualizer {
            constructor(canvasElement, screenSize) {
                this.canvas = canvasElement;
                this.ctx = this.canvas.getContext('2d');
                this.w_width = screenSize[0];
                this.w_height = screenSize[1];
                this.node_size = 15;
                this.scale = 0.75;
                this.fontSizeBase = 30;
            }

            draw(animal) {
                const nn = animal.brain;
                const markedNodeIdx = animal.outputIdx;

                // Clear with transparency instead of filling background
                this.ctx.clearRect(0, 0, this.w_width, this.w_height);

                const allNodesPos = this.drawNodes(nn, markedNodeIdx);
                const weights = this.extractWeights(nn);
                
                if (weights.length > 0) {
                    const [minWeight, maxWeight] = this.getWeightRange(weights);
                    this.drawEdges(allNodesPos, weights, minWeight, maxWeight);
                }
                
                // Draw label after nodes
                this.drawLabel(nn);
            }

            drawLabel(nn) {
                const networkLabel = this.getNetworkLabel(nn);
                
                this.ctx.fillStyle = 'rgba(0, 255, 0, 0.6)';
                this.ctx.font = `10px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.fillText(networkLabel, this.w_width / 2, this.w_height - 5);
            }

            getNetworkLabel(nn) {
                if (nn.weights && nn.weights.length > 0 && typeof nn.weights[0] === 'object') {
                    if (nn.weights[0].W_i !== undefined) {
                        return 'LSTMNetwork';
                    }
                }
                return 'DenseNetwork';
            }

            drawNodes(nn, markedNodeIdx) {
                const layerDims = this.getLayerDims(nn);
                const padding = this.w_width * 0.1;
                const availableWidth = this.w_width - (padding * 2);
                const availableHeight = this.w_height - (padding * 2);
                
                const w_stride = availableWidth / Math.max(layerDims.length - 1, 1);
                const nn_len = layerDims.length;
                const allNodesPos = [];

                this.node_size = Math.min(this.w_height * 0.04, 5);

                for (let l_idx = 0; l_idx < nn_len; l_idx++) {
                    const l_nodes_pos = [];
                    const num_nodes = layerDims[l_idx];
                    const h_stride = availableHeight / Math.max(num_nodes - 1, 1);

                    for (let n_idx = 0; n_idx < num_nodes; n_idx++) {
                        const x = padding + (l_idx * w_stride);
                        const y = padding + (n_idx * h_stride);

                        let nodeColor = 'rgba(0, 255, 0, 0.8)';
                        if (l_idx === nn_len - 1 && n_idx === markedNodeIdx) {
                            nodeColor = 'rgba(255, 0, 0, 1)';
                        }

                        this.ctx.strokeStyle = nodeColor;
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, this.node_size, 0, 2 * Math.PI);
                        this.ctx.stroke();

                        l_nodes_pos.push([x, y]);
                    }
                    allNodesPos.push(l_nodes_pos);
                }

                return allNodesPos;
            }

            drawEdges(allNodesPos, weights, minWeight, maxWeight) {
                for (let l_idx = 0; l_idx < allNodesPos.length - 1; l_idx++) {
                    for (let n1_idx = 0; n1_idx < allNodesPos[l_idx].length; n1_idx++) {
                        for (let n2_idx = 0; n2_idx < allNodesPos[l_idx + 1].length; n2_idx++) {
                            const weight = weights[l_idx][n1_idx][n2_idx];

                            const threshold = minWeight + (maxWeight - minWeight) * 0.1;
                            if (Math.abs(weight) < Math.abs(threshold)) {
                                continue;
                            }

                            const currentNodePos = allNodesPos[l_idx][n1_idx];
                            const nextNodePos = allNodesPos[l_idx + 1][n2_idx];

                            const scaledWeight =
                                maxWeight !== minWeight
                                    ? (weight - minWeight) / (maxWeight - minWeight)
                                    : 0.5;

                            const lineColor = this.getWeightColor(weight, scaledWeight);

                            this.ctx.strokeStyle = lineColor;
                            this.ctx.lineWidth = 1;
                            this.ctx.globalAlpha = 0.6;
                            this.ctx.beginPath();
                            this.ctx.moveTo(currentNodePos[0], currentNodePos[1]);
                            this.ctx.lineTo(nextNodePos[0], nextNodePos[1]);
                            this.ctx.stroke();
                            this.ctx.globalAlpha = 1.0;
                        }
                    }
                }
            }

            extractWeights(nn) {
                if (!nn.weights) {
                    return [];
                }

                if (Array.isArray(nn.weights) && nn.weights.length > 0) {
                    const firstLayer = nn.weights[0];

                    if (firstLayer && typeof firstLayer === 'object' && firstLayer.W_i !== undefined) {
                        return this.extractLSTMWeights(nn);
                    }

                    return nn.weights;
                }

                return [];
            }

            extractLSTMWeights(nn) {
                const combined = [];

                if (nn.weights && Array.isArray(nn.weights)) {
                    for (let lstm_layer of nn.weights) {
                        const W_i = lstm_layer.W_i || [];
                        const W_f = lstm_layer.W_f || [];
                        const W_c = lstm_layer.W_c || [];
                        const W_o = lstm_layer.W_o || [];

                        const avgWeight = this.averageMatrices([W_i, W_f, W_c, W_o]);
                        combined.push(avgWeight);
                    }
                }

                if (nn.V) {
                    combined.push(nn.V);
                }

                return combined;
            }

            averageMatrices(matrices) {
                if (matrices.length === 0) return [];
                if (matrices[0].length === 0) return [];

                const rows = matrices[0].length;
                const cols = matrices[0][0].length;
                const result = Array(rows).fill(null).map(() => Array(cols).fill(0));

                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        let sum = 0;
                        for (let mat of matrices) {
                            if (mat[i] && mat[i][j] !== undefined) {
                                sum += mat[i][j];
                            }
                        }
                        result[i][j] = sum / matrices.length;
                    }
                }

                return result;
            }

            getLayerDims(nn) {
                if (nn.layerDims) {
                    return nn.layerDims;
                }
                if (nn.layer_dims) {
                    return nn.layer_dims;
                }

                const dims = [];
                if (nn.weights && Array.isArray(nn.weights)) {
                    dims.push(nn.weights[0].length);
                    for (let layer of nn.weights) {
                        if (layer[0]) {
                            dims.push(layer[0].length);
                        }
                    }
                }

                return dims.length > 0 ? dims : [6, 6, 9, 8, 8];
            }

            getWeightRange(weights) {
                let min = Infinity;
                let max = -Infinity;

                for (let layer of weights) {
                    for (let row of layer) {
                        for (let w of row) {
                            if (w < min) min = w;
                            if (w > max) max = w;
                        }
                    }
                }

                return [min === Infinity ? -1 : min, max === -Infinity ? 1 : max];
            }

            getWeightColor(weight, maxAbsWeight = 1.0) {
                if (maxAbsWeight === 0) {
                    maxAbsWeight = 1.0;
                }

                let normalized = weight / maxAbsWeight;
                normalized = Math.max(-1.0, Math.min(1.0, normalized));

                let r, g, b;

                if (normalized < 0) {
                    r = 255;
                    g = Math.floor(255 * (1 + normalized));
                    b = Math.floor(255 * (1 + normalized));
                } else {
                    r = Math.floor(255 * (1 - normalized));
                    g = Math.floor(255 * (1 - normalized));
                    b = 255;
                }

                const isGrayish =
                    Math.abs(r - g) < 20 &&
                    Math.abs(g - b) < 20 &&
                    Math.abs(r - b) < 20;
                const alpha = isGrayish ? 0.3 : 0.7;

                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }

            resize(screenSize) {
                this.w_width = screenSize[0];
                this.w_height = screenSize[1];
                this.canvas.width = this.w_width;
                this.canvas.height = this.w_height;
            }
        }

        // ============================================================================
        // CONFIGURATION
        // ============================================================================

        const CONFIG = {
            isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
            isDeviceTilt: window.DeviceOrientationEvent !== undefined,
            initialDeer: 20,
            initialWolves: 5,
            initialPlants: 30,
            worldWidth: 850,
            worldHeight: 600,
            maxDrawDistance: 2000
        };

        // ============================================================================
        // THREE.JS SETUP
        // ============================================================================

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue
        scene.fog = new THREE.Fog(0x87CEEB, 1500, CONFIG.maxDrawDistance);

        const canvas = document.getElementById('canvas');
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            CONFIG.maxDrawDistance
        );
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: 'high-performance' });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFShadowShadowMap;

        camera.position.set(400, 300, 300);

        // ============================================================================
        // NEURAL NETWORK VISUALIZER SETUP
        // ============================================================================

        const nnCanvas = document.getElementById('nnCanvas');
        const nnContainer = document.getElementById('nnVisualizerContainer');
        const nnLabel = document.getElementById('nnLabel');
        let nnVisualizer = null;
        let nnVisEnabled = false;

        function initNNVisualizer() {
            const wrapper = document.getElementById('nnCanvasWrapper');
            // Force layout recalculation
            wrapper.offsetHeight;
            const rect = wrapper.getBoundingClientRect();
            const width = Math.max(rect.width, 200);
            const height = Math.max(rect.height, 200);
            nnCanvas.width = width;
            nnCanvas.height = height;
            nnVisualizer = new NNVisualizer(nnCanvas, [width, height]);
        }

        document.getElementById('nnVisBtn').addEventListener('click', () => {
            nnVisEnabled = !nnVisEnabled;
            const btn = document.getElementById('nnVisBtn');
            if (nnVisEnabled) {
                nnContainer.classList.add('show');
                btn.textContent = 'Hide NN';
                // Initialize on next frame to ensure DOM is ready
                requestAnimationFrame(() => {
                    if (!nnVisualizer) {
                        initNNVisualizer();
                    }
                });
            } else {
                nnContainer.classList.remove('show');
                btn.textContent = 'Show NN';
            }
        });

        // ============================================================================
        // LIGHTING
        // ============================================================================

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
        directionalLight.position.set(800, 400, 600);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.left = -1000;
        directionalLight.shadow.camera.right = 1000;
        directionalLight.shadow.camera.top = 1000;
        directionalLight.shadow.camera.bottom = -1000;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 2000;
        scene.add(directionalLight);

        // ============================================================================
        // TOUCH & DEVICE CONTROLS
        // ============================================================================

        const controls = {
            touchX: 0,
            touchY: 0,
            joystickActive: false,
            joystickX: 0,
            joystickY: 0,
            deviceAlpha: 0,
            deviceBeta: 0,
            deviceGamma: 0,
            hasPermission: false,
            controlMode: 'touch' // 'touch' or 'keyboard'
        };

        const keys = {};

        // Keyboard input
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === ' ') {
                e.preventDefault();
                if (!player.isJumping) {
                    player.velocity.y = player.jumpForce;
                    player.isJumping = true;
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Mouse movement for camera look
        document.addEventListener('mousemove', (e) => {
            if (controls.controlMode === 'keyboard') {
                const deltaX = e.movementX || 0;
                const deltaY = e.movementY || 0;

                player.yaw -= deltaX * 0.005;
                player.pitch -= deltaY * 0.005;
                player.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.pitch));
            }
        });

        // Request pointer lock for mouse
        document.addEventListener('click', () => {
            if (controls.controlMode === 'keyboard') {
                canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
                canvas.requestPointerLock();
            }
        });

        // Control mode toggle
        document.getElementById('controlBtn').addEventListener('click', () => {
            controls.controlMode = controls.controlMode === 'touch' ? 'keyboard' : 'touch';
            const btn = document.getElementById('controlBtn');
            btn.textContent = controls.controlMode === 'touch' ? 'Keyboard' : 'Touch';
            
            // Reset movement on switch
            controls.joystickX = 0;
            controls.joystickY = 0;
            Object.keys(keys).forEach(k => keys[k] = false);
            
            // Update UI visibility
            const joystick = document.getElementById('joystick');
            if (controls.controlMode === 'touch') {
                joystick.classList.add('show');
            } else {
                joystick.classList.remove('show');
            }
        });

        // Setup joystick
        const joystickEl = document.getElementById('joystick');
        const joystickKnob = document.createElement('div');
        joystickKnob.className = 'joystick-knob';
        joystickEl.appendChild(joystickKnob);

        let joystickStartX = 0;
        let joystickStartY = 0;
        let joystickRadius = 0;

        joystickEl.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = joystickEl.getBoundingClientRect();
            joystickStartX = rect.left + rect.width / 2;
            joystickStartY = rect.top + rect.height / 2;
            joystickRadius = rect.width / 2 - 25;
            controls.joystickActive = true;
            handleJoystickMove(touch.clientX, touch.clientY);
        });

        document.addEventListener('touchmove', (e) => {
            if (controls.joystickActive && e.touches.length > 0) {
                handleJoystickMove(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false });

        document.addEventListener('touchend', () => {
            controls.joystickActive = false;
            controls.joystickX = 0;
            controls.joystickY = 0;
            joystickKnob.style.transform = 'translate(-50%, -50%)';
        });

        function handleJoystickMove(x, y) {
            let deltaX = x - joystickStartX;
            let deltaY = y - joystickStartY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            if (distance > joystickRadius) {
                const angle = Math.atan2(deltaY, deltaX);
                deltaX = Math.cos(angle) * joystickRadius;
                deltaY = Math.sin(angle) * joystickRadius;
            }

            controls.joystickX = deltaX / joystickRadius;
            controls.joystickY = deltaY / joystickRadius;

            joystickKnob.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
        }

        // Touch screen camera control and double tap jump
        let cameraControlActive = false;
        let touchStartX = 0;
        let touchStartY = 0;
        let lastTapTime = 0;
        let lastTapX = 0;
        let lastTapY = 0;

        document.addEventListener('touchstart', (e) => {
            const touch = e.touches[0];
            const target = touch.target;

            // Don't intercept if touching buttons or interactive elements
            if (target.tagName === 'BUTTON' || target.closest('button') || target.closest('.control-panel')) {
                return;
            }

            // Check if touch is outside the joystick area
            const joystickRect = joystickEl.getBoundingClientRect();
            
            const isOutsideJoystick = (
                touch.clientX < joystickRect.left || 
                touch.clientX > joystickRect.right ||
                touch.clientY < joystickRect.top || 
                touch.clientY > joystickRect.bottom
            );

            // Double tap detection for jump
            const currentTime = Date.now();
            const tapDistance = Math.hypot(touch.clientX - lastTapX, touch.clientY - lastTapY);
            
            if (isOutsideJoystick && controls.controlMode === 'touch' && e.touches.length === 1) {
                if (currentTime - lastTapTime < 300 && tapDistance < 50) {
                    // Jump
                    if (!player.isJumping) {
                        player.velocity.y = player.jumpForce;
                        player.isJumping = true;
                    }
                } else {
                    // Camera control
                    cameraControlActive = true;
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                }
                
                lastTapTime = currentTime;
                lastTapX = touch.clientX;
                lastTapY = touch.clientY;
                e.preventDefault();
            }
        }, { passive: false });

        document.addEventListener('touchmove', (e) => {
            if (cameraControlActive && e.touches.length === 1) {
                const touch = e.touches[0];
                const deltaX = touch.clientX - touchStartX;
                const deltaY = touch.clientY - touchStartY;

                player.yaw -= deltaX * 0.005;
                player.pitch -= deltaY * 0.005;
                player.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.pitch));

                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                e.preventDefault();
            }
        }, { passive: false });

        document.addEventListener('touchend', (e) => {
            if (e.touches.length === 0) {
                cameraControlActive = false;
            }
        });

        // ============================================================================
        // PLAYER
        // ============================================================================

        const player = {
            position: new THREE.Vector3(400, 100, 300),
            velocity: new THREE.Vector3(0, 0, 0),
            speed: 40,
            sprintSpeed: 80,
            jumpForce: 300,
            isJumping: false,
            yaw: 0,
            pitch: 0,
            targetObject: null
        };

        // ============================================================================
        // TERRAIN GENERATION
        // ============================================================================

        function createTerrain() {
            const geometry = new THREE.PlaneGeometry(CONFIG.worldWidth, CONFIG.worldHeight, 50, 50);
            const material = new THREE.MeshLambertMaterial({ color: 0x2d5016 });

            const positionAttribute = geometry.getAttribute('position');
            const positions = positionAttribute.array;

            for (let i = 2; i < positions.length; i += 3) {
                positions[i] = 5;
            }
            positionAttribute.needsUpdate = true;
            geometry.computeVertexNormals();

            const terrain = new THREE.Mesh(geometry, material);
            terrain.receiveShadow = true;
            terrain.rotation.x = -Math.PI / 2;
            terrain.position.set(CONFIG.worldWidth / 2, 0, CONFIG.worldHeight / 2);
            return terrain;
        }

        // ============================================================================
        // NEURAL NETWORK UTILITIES
        // ============================================================================

        const tools = {
            distance(x1, y1, x2, y2) {
                return (x2 - x1) ** 2 + (y2 - y1) ** 2;
            },

            clamp(value, minimum, maximum) {
                return Math.max(Math.min(value, maximum), minimum);
            },

            sigmoid(x) {
                x = Math.max(-500, Math.min(500, x));
                return x >= 0 ? 1 / (1 + Math.exp(-x)) : Math.exp(x) / (1 + Math.exp(x));
            },

            softmax(vector) {
                const max = Math.max(...vector);
                const exps = vector.map(v => Math.exp(v - max));
                const sum = exps.reduce((a, b) => a + b, 0);
                return exps.map(exp => exp / sum);
            },

            random(min = 0, max = 1) {
                return Math.random() * (max - min) + min;
            }
        };

        class DenseNetwork {
            constructor(inputDims, layerDims, learningRate = 0.01, momentum = 0.9, weightDecay = 0.0001) {
                this.layerDims = [inputDims, ...layerDims];
                this.learningRate = learningRate;
                this.momentum = momentum;
                this.weightDecay = weightDecay;
                this.cost = 0.0;
                this.costHistory = [];
                this.output = null;

                this.weights = [];
                this.biases = [];
                this.weightVelocity = [];
                this.biasVelocity = [];

                for (let i = 0; i < this.layerDims.length - 1; i++) {
                    this.weights.push(this.xavierInit(this.layerDims[i], this.layerDims[i + 1]));
                    this.biases.push(new Array(this.layerDims[i + 1]).fill(0));
                    this.weightVelocity.push(this.weights[i].map(row => row.map(() => 0)));
                    this.biasVelocity.push(new Array(this.layerDims[i + 1]).fill(0));
                }
            }

            xavierInit(inDim, outDim) {
                const limit = Math.sqrt(6.0 / (inDim + outDim));
                const layer = [];
                for (let i = 0; i < inDim; i++) {
                    layer[i] = [];
                    for (let j = 0; j < outDim; j++) {
                        layer[i][j] = tools.random(-limit, limit);
                    }
                }
                return layer;
            }

            propagate(inputs) {
                let slidingLayer = inputs;

                for (let lIdx = 0; lIdx < this.layerDims.length - 1; lIdx++) {
                    let outLayer = [...this.biases[lIdx]];

                    for (let n1Idx = 0; n1Idx < slidingLayer.length; n1Idx++) {
                        for (let n2Idx = 0; n2Idx < this.layerDims[lIdx + 1]; n2Idx++) {
                            outLayer[n2Idx] += slidingLayer[n1Idx] * this.weights[lIdx][n1Idx][n2Idx];
                        }
                    }

                    if (lIdx < this.layerDims.length - 2) {
                        slidingLayer = outLayer.map(v => tools.sigmoid(v));
                    } else {
                        slidingLayer = outLayer;
                    }
                }

                return tools.softmax(slidingLayer);
            }

            think(inputs) {
                const values = this.propagate(inputs);
                this.output = values.indexOf(Math.max(...values));
                return this.output;
            }

            getAdaptiveLr() {
                if (this.costHistory.length > 0 && this.cost < this.costHistory[this.costHistory.length - 1]) {
                    this.learningRate *= 1.05 * 0.001;
                } else {
                    this.learningRate *= 0.95 * 0.001;
                }

                this.learningRate = Math.max(0.0001, Math.min(0.1, this.learningRate));
                this.costHistory.push(this.cost);
                if (this.costHistory.length > 100) {
                    this.costHistory.shift();
                }
                return this.learningRate;
            }

            adjustWeights(cost) {
                this.cost = cost;
                const normalizedCost = Math.max(-1.0, Math.min(1.0, this.cost));
                const adaptiveLr = this.getAdaptiveLr();

                for (let lIdx = 0; lIdx < this.weights.length; lIdx++) {
                    for (let n1Idx = 0; n1Idx < this.weights[lIdx].length; n1Idx++) {
                        for (let n2Idx = 0; n2Idx < this.weights[lIdx][n1Idx].length; n2Idx++) {
                            const velocity = this.momentum * this.weightVelocity[lIdx][n1Idx][n2Idx] - adaptiveLr * normalizedCost;
                            this.weightVelocity[lIdx][n1Idx][n2Idx] = velocity;
                            this.weights[lIdx][n1Idx][n2Idx] = this.weights[lIdx][n1Idx][n2Idx] * (1 - this.weightDecay) + velocity;
                        }
                    }
                }

                for (let lIdx = 0; lIdx < this.biases.length; lIdx++) {
                    for (let bIdx = 0; bIdx < this.biases[lIdx].length; bIdx++) {
                        const velocity = this.momentum * this.biasVelocity[lIdx][bIdx] - adaptiveLr * 0.1 * normalizedCost;
                        this.biasVelocity[lIdx][bIdx] = velocity;
                        this.biases[lIdx][bIdx] = this.biases[lIdx][bIdx] * (1 - this.weightDecay * 0.1) + velocity;
                    }
                }
            }
        }

        // ============================================================================
        // ENTITY SYSTEM
        // ============================================================================

        class Entity {
            constructor(position, type) {
                this.position = new THREE.Vector3(...position);
                this.type = type;
                this.mesh = null;
                this.health = 100;
                this.alive = true;
            }

            update(deltaTime) {}

            remove() {
                if (this.mesh) scene.remove(this.mesh);
            }
        }

        class Animal extends Entity {
            constructor(position, type) {
                super(position, type);
                this.speciesType = type;
                this.speed = type === 'wolf' ? 35 : 25;
                this.startHealth = type === 'wolf' ? 120 : 100;
                this.health = this.startHealth;
                this.maxHealth = this.health;
                this.visionDistance = tools.random(80, 150);
                this.generation = 0;
                
                // Resource tracking
                this.waterNeed = Math.random() * 0.02 + 0.01;
                this.foodNeed = Math.random() * 0.02 + 0.01;
                this.reproductionNeed = Math.random() * 0.02 + 0.01;
                this.avoidNeed = 0;

                // Degradation rates
                this.waterIncrement = this.health * 0.0001;
                this.foodIncrement = this.health * 0.0001;
                this.ageDepl = this.health * 0.00002;

                // Memory and priorities
                this.memory = { predator: null, food: null, water: null, mate: null };
                this.priority = null;

                // Movement system
                this.coordChanges = [
                    [this.speed, 0], [-this.speed, 0], [0, this.speed], [0, -this.speed],
                    [this.speed * 0.7, this.speed * 0.7], [this.speed * 0.7, -this.speed * 0.7],
                    [-this.speed * 0.7, this.speed * 0.7], [-this.speed * 0.7, -this.speed * 0.7]
                ];

                // Neural network
                this.numInputs = 6;
                this.nnLayerDims = [this.numInputs, this.numInputs, 9, this.coordChanges.length];
                this.brain = new DenseNetwork(this.numInputs, this.nnLayerDims.slice(1), 0.01);
                this.outputIdx = 0;
                this.brainUpdateCounter = 0;

                // Tracking
                this.coordsFocused = new THREE.Vector2(this.position.x, this.position.z);
                this.tob = Date.now();

                this.createMesh();
            }

            createMesh() {
                if (this.type === 'deer') {
                    const group = new THREE.Group();
                    const body = new THREE.Mesh(
                        new THREE.BoxGeometry(15, 15, 25),
                        new THREE.MeshStandardMaterial({ color: 0xE6E6E6 })
                    );
                    body.castShadow = true;
                    body.receiveShadow = true;
                    group.add(body);

                    const head = new THREE.Mesh(
                        new THREE.SphereGeometry(10, 16, 16),
                        new THREE.MeshStandardMaterial({ color: 0xE6E6E6 })
                    );
                    head.position.z = 15;
                    head.castShadow = true;
                    head.receiveShadow = true;
                    group.add(head);

                    this.mesh = group;
                } else if (this.type === 'wolf') {
                    const group = new THREE.Group();
                    const body = new THREE.Mesh(
                        new THREE.BoxGeometry(15, 15, 25),
                        new THREE.MeshStandardMaterial({ color: 0x81613e })
                    );
                    body.castShadow = true;
                    body.receiveShadow = true;
                    group.add(body);

                    const head = new THREE.Mesh(
                        new THREE.SphereGeometry(10, 16, 16),
                        new THREE.MeshStandardMaterial({ color: 0x81613e })
                    );
                    head.position.z = 15;
                    head.castShadow = true;
                    head.receiveShadow = true;
                    group.add(head);

                    this.mesh = group;
                }

                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }

            getDirectionFromOutput() {
                const angles = [
                    Math.PI / 2,         // 0: +X direction right
                    -Math.PI / 2,          // 1: -X direction left
                    0,                    // 2: +Z direction forward
                    Math.PI,              // 3: -Z direction backward
                    Math.PI / 4,         // 4: +X+Z diagonal (between -œÄ/2 and 0)
                    3 * Math.PI / 4,     // 5: +X-Z diagonal (between -œÄ/2 and œÄ)
                    -Math.PI / 4,          // 6: -X+Z diagonal (between œÄ/2 and 0) forward left
                    -3 * Math.PI / 4       // 7: -X-Z diagonal (between œÄ/2 and œÄ)
                ];
                return angles[this.outputIdx % 8];
            }

            locate(entities, waterLocations) {
                const objDistances = { predator: Infinity, food: Infinity, water: Infinity, mate: Infinity };

                for (let obj of entities) {
                    if (obj === this || !(obj instanceof Animal)) continue;
                    const objDist = tools.distance(this.position.x, this.position.z, obj.position.x, obj.position.z);
                    const inSight = objDist <= this.visionDistance ** 2;

                    if (!inSight) continue;

                    if (this.type === 'deer' && obj.type === 'wolf') {
                        if (objDist < objDistances.predator) {
                            objDistances.predator = objDist;
                            this.memory.predator = [obj.position.x, obj.position.z];
                            this.avoidNeed = 0.5;
                        }
                    } else if (this.type === 'wolf' && obj.type === 'deer' && objDist < objDistances.food) {
                        objDistances.food = objDist;
                        this.memory.food = [obj.position.x, obj.position.z];
                    } else if (this.type === 'deer' && obj.type === 'deer' && objDist < objDistances.mate) {
                        objDistances.mate = objDist;
                        this.memory.mate = [obj.position.x, obj.position.z];
                    }
                }

                for (let water of waterLocations) {
                    const objDist = tools.distance(this.position.x, this.position.z, water[0], water[1]);
                    if (objDist < objDistances.water) {
                        objDistances.water = objDist;
                        this.memory.water = [water[0], water[1]];
                    }
                }
            }

            think(entities, waterLocations) {
                this.locate(entities, waterLocations);

                const needs = {
                    predator: this.avoidNeed,
                    food: this.foodNeed,
                    water: this.waterNeed,
                    mate: this.reproductionNeed
                };

                const priorityList = Object.entries(needs).sort((a, b) => b[1] - a[1]);

                for (let [need, _] of priorityList) {
                    const needLocation = this.memory[need];
                    if (needLocation !== null) {
                        this.priority = need;
                        this.coordsFocused.x = needLocation[0];
                        this.coordsFocused.y = needLocation[1];
                        break;
                    }
                }

                // Map inputs for neural network
                const healthDiff = this.health - this.startHealth;
                const xRelative = Math.abs(this.position.x - this.coordsFocused.x) / CONFIG.worldWidth;
                const yRelative = Math.abs(this.position.z - this.coordsFocused.y) / CONFIG.worldHeight;
                const sign = this.type === 'wolf' ? -1 : 1;

                const inputs = [xRelative, yRelative, sign, this.foodNeed, this.waterNeed, this.reproductionNeed];
                this.brain.cost = healthDiff;

                const agentsChoice = this.brain.think(inputs);
                this.outputIdx = agentsChoice;
            }

            move() {
                const coordChange = this.coordChanges[this.outputIdx];
                this.position.x += coordChange[0] * 0.016; // deltaTime compensation
                this.position.z += coordChange[1] * 0.016;

                // Wrap around world
                this.position.x = ((this.position.x % CONFIG.worldWidth) + CONFIG.worldWidth) % CONFIG.worldWidth;
                this.position.z = ((this.position.z % CONFIG.worldHeight) + CONFIG.worldHeight) % CONFIG.worldHeight;

                // Update mesh position and rotation
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                    this.mesh.rotation.y = this.getDirectionFromOutput();
                }
            }

            updateResourcesNeed() {
                this.waterNeed += this.waterIncrement;
                this.foodNeed += this.foodIncrement;
            }

            updateMemory() {
                for (let key of Object.keys(this.memory)) {
                    const loc = this.memory[key];
                    if (loc !== null && tools.distance(this.position.x, this.position.z, loc[0], loc[1]) > this.visionDistance ** 2) {
                        this.memory[key] = null;
                    }
                }
            }

            update(deltaTime, entities, waterLocations) {
                this.updateResourcesNeed();
                this.updateMemory();

                const elapsedTime = (Date.now() - this.tob) / 1000;
                this.health -= elapsedTime * this.ageDepl;
                this.health -= this.waterNeed * 0.0001;
                this.health -= this.foodNeed * 0.0001;

                this.avoidNeed = 0;

                // Check for death
                if (this.health <= 1) {
                    this.alive = false;
                }

                // Think and move
                this.think(entities, waterLocations);
                this.brainUpdateCounter++;
                if (this.brainUpdateCounter >= 5) {
                    this.brain.adjustWeights(this.health - this.startHealth);
                    this.brainUpdateCounter = 0;
                }
                this.move();

                // Update mesh
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                }
            }

            attacked(predator) {
                const healthDepl = this.startHealth * 0.1;
                this.health -= healthDepl;
                if (this.health <= 1) {
                    this.alive = false;
                    predator.health += this.startHealth;
                    predator.foodNeed = Math.max(0, predator.foodNeed - this.startHealth);
                }
            }

            eatPlant(plant) {
                const plantNutrition = plant.maxHealth * 5;
                this.health = Math.min(this.health + plantNutrition, this.maxHealth);
                this.foodNeed = Math.max(0, this.foodNeed - plantNutrition * 0.01);
                plant.health -= 1;
                if (plant.health <= 0) {
                    plant.alive = false;
                }
            }

            drinkWater() {
                this.waterNeed = Math.max(0, this.waterNeed - this.waterIncrement * 10);
            }
        }

        class Plant extends Entity {
            constructor(position) {
                super(position, 'plant');
                this.health = 5;
                this.maxHealth = 5;
                this.createMesh();
            }

            createMesh() {
                const group = new THREE.Group();
                
                for (let i = 0; i < 4; i++) {
                    const leaf = new THREE.Mesh(
                        new THREE.SphereGeometry(2, 4, 4),
                        new THREE.MeshStandardMaterial({ color: 0x228b22 })
                    );
                    const angle = (i / 4) * Math.PI * 2;
                    leaf.position.x = Math.cos(angle) * 4;
                    leaf.position.z = Math.sin(angle) * 4;
                    leaf.position.y = 5;
                    leaf.castShadow = true;
                    leaf.receiveShadow = true;
                    group.add(leaf);
                }

                const stem = new THREE.Mesh(
                    new THREE.CylinderGeometry(2, 2, 10, 8),
                    new THREE.MeshStandardMaterial({ color: 0x228b22 })
                );
                stem.castShadow = true;
                stem.receiveShadow = true;
                group.add(stem);

                this.mesh = group;
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
                this.updateScale();
            }

            updateScale() {
                const healthRatio = this.health / this.maxHealth;
                this.mesh.scale.set(healthRatio, healthRatio, healthRatio);
            }

            update() {
                this.updateScale();
            }
        }

        class Water extends Entity {
            constructor(position) {
                super(position, 'water');
                this.createMesh();
            }

            createMesh() {
                const geometry = new THREE.PlaneGeometry(20, 20);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x4a90e2,
                    metalness: 0.3,
                    roughness: 0.4
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.copy(this.position);
                mesh.receiveShadow = true;
                this.mesh = mesh;
                scene.add(this.mesh);
            }
        }

        // ============================================================================
        // WORLD STATE
        // ============================================================================

        let entities = [];
        let terrian = new THREE.Mesh(0, 0);
        let waterLocations = [];
        let ticks = 0;
        let lastFpsUpdate = 0;
        let frameCount = 0;
        // Add raycaster helper
        let raycastHelper = new THREE.Raycaster();

        function initializeWorld() {
            // Clear scene
            entities.forEach(e => e.remove());
            entities = [];
            waterLocations = [];
            scene.remove(terrian.mesh)

            // Add terrain
            terrain = createTerrain();
            scene.add(terrain);

            // Add water bodies and track locations
            for (let i = 0; i < 3; i++) {
                let clusterX, clusterZ, isValidCluster = false;
                const clusterRadius = 60; // Radius around cluster center
                
                // Find a valid cluster location that doesn't overlap with existing ones
                while (!isValidCluster) {
                    clusterX = Math.random() * CONFIG.worldWidth;
                    clusterZ = Math.random() * CONFIG.worldHeight;
                    
                    // Check if this cluster overlaps with existing water clusters
                    isValidCluster = true;
                    for (let existing of waterLocations) {
                        const dist = Math.sqrt(
                            Math.pow(clusterX - existing[0], 2) + 
                            Math.pow(clusterZ - existing[1], 2)
                        );
                        if (dist < clusterRadius * 2) {
                            isValidCluster = false;
                            break;
                        }
                    }
                }
                
                // Place individual water tiles in this cluster
                for (let j = 0; j < 15; j++) {
                    let wx, wz, isValidPosition = false;
                    const tileRadius = 10; // Minimum distance between individual water tiles
                    
                    // Find valid position within cluster
                    while (!isValidPosition) {
                        wx = clusterX + (Math.random() - 0.5) * clusterRadius * 2;
                        wz = clusterZ + (Math.random() - 0.5) * clusterRadius * 2;
                        
                        // Keep within world bounds
                        if (wx < 0 || wx > CONFIG.worldWidth || wz < 0 || wz > CONFIG.worldHeight) {
                            continue;
                        }
                        
                        // Check distance from other water tiles in this cluster
                        isValidPosition = true;
                        for (let existing of waterLocations) {
                            const dist = Math.sqrt(
                                Math.pow(wx - existing[0], 2) + 
                                Math.pow(wz - existing[1], 2)
                            );
                            if (dist < tileRadius) {
                                isValidPosition = false;
                                break;
                            }
                        }
                    }
                    
                    entities.push(new Water([wx, 6, wz]));
                    waterLocations.push([wx, wz]);
                }
            }

            // Add plants
            for (let i = 0; i < CONFIG.initialPlants; i++) {
                entities.push(new Plant([
                    Math.random() * CONFIG.worldWidth,
                    3,
                    Math.random() * CONFIG.worldHeight
                ]));
            }

            // Add deer
            for (let i = 0; i < CONFIG.initialDeer; i++) {
                entities.push(new Animal([
                    Math.random() * CONFIG.worldWidth,
                    15,
                    Math.random() * CONFIG.worldHeight
                ], 'deer'));
            }

            // Add wolves
            for (let i = 0; i < CONFIG.initialWolves; i++) {
                entities.push(new Animal([
                    Math.random() * CONFIG.worldWidth,
                    15,
                    Math.random() * CONFIG.worldHeight
                ], 'wolf'));
            }

            camera.position.copy(player.position);
            player.targetObject = null;
        }

        function updateStats() {
            const deer = entities.filter(e => e.type === 'deer' && e.alive).length;
            const wolves = entities.filter(e => e.type === 'wolf' && e.alive).length;
            const plants = entities.filter(e => e.type === 'plant' && e.alive).length;

            document.getElementById('deerCount').textContent = deer;
            document.getElementById('wolfCount').textContent = wolves;
            document.getElementById('plantCount').textContent = plants;
            document.getElementById('dayCount').textContent = Math.floor(ticks / (24 * 60));
        }

        function handleCollisions() {
            const animals = entities.filter(e => e instanceof Animal && e.alive);
            const plants = entities.filter(e => e instanceof Plant && e.alive);

            // Wolf-Deer interactions
            for (let wolf of animals.filter(a => a.type === 'wolf')) {
                for (let deer of animals.filter(a => a.type === 'deer')) {
                    const dist = tools.distance(wolf.position.x, wolf.position.z, deer.position.x, deer.position.z);
                    if (dist < 200) {
                        deer.attacked(wolf);
                    }
                }
            }

            // Deer-Plant interactions
            for (let deer of animals.filter(a => a.type === 'deer')) {
                for (let plant of plants) {
                    const dist = tools.distance(deer.position.x, deer.position.z, plant.position.x, plant.position.z);
                    if (dist < 200) {
                        deer.eatPlant(plant);
                    }
                }
            }

            // Deer-Water interactions
            for (let deer of animals.filter(a => a.type === 'deer')) {
                for (let water of waterLocations) {
                    const dist = tools.distance(deer.position.x, deer.position.z, water[0], water[1]);
                    if (dist < 200) {
                        deer.drinkWater();
                        deer.waterNeed = Math.max(0, deer.waterNeed - deer.waterIncrement * 10);
                    }
                }
            }

            // Wolf-Water interactions
            for (let wolf of animals.filter(a => a.type === 'wolf')) {
                for (let water of waterLocations) {
                    const dist = tools.distance(wolf.position.x, wolf.position.z, water[0], water[1]);
                    if (dist < 200) {
                        wolf.drinkWater();
                        wolf.waterNeed = Math.max(0, wolf.waterNeed - wolf.waterIncrement * 10);
                    }
                }
            }
        }

        function updatePlayer(deltaTime) {
            let moveVector = new THREE.Vector3(0, 0, 0);

            if (controls.controlMode === 'keyboard') {
                // Keyboard controls
                const currentSpeed = keys['shift'] ? player.sprintSpeed : player.speed;
                
                if (keys['w']) moveVector.z -= currentSpeed * deltaTime;
                if (keys['s']) moveVector.z += currentSpeed * deltaTime;
                if (keys['a']) moveVector.x -= currentSpeed * deltaTime;
                if (keys['d']) moveVector.x += currentSpeed * deltaTime;
            } else {
                // Touch joystick controls
                const currentSpeed = player.speed;
                moveVector.x = controls.joystickX * currentSpeed * deltaTime;
                moveVector.z = controls.joystickY * currentSpeed * deltaTime;
            }

            // Apply rotation to movement
            const rotationMatrix = new THREE.Matrix4();
            rotationMatrix.makeRotationY(player.yaw);
            moveVector.applyMatrix4(rotationMatrix);

            player.position.add(moveVector);

            // Wrap world
            player.position.x = ((player.position.x % CONFIG.worldWidth) + CONFIG.worldWidth) % CONFIG.worldWidth;
            player.position.z = ((player.position.z % CONFIG.worldHeight) + CONFIG.worldHeight) % CONFIG.worldHeight;

            // Apply gravity
            player.velocity.y -= 300 * deltaTime; // gravity
            player.position.y += player.velocity.y * deltaTime;

            // Ground collision
            if (player.position.y < 35) {
                player.position.y = 35;
                player.velocity.y = 0;
                player.isJumping = false;
            }

            // Update camera
            camera.position.copy(player.position);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = player.yaw;
            camera.rotation.x = player.pitch;

            // Update speed indicator
            let speed = 0;
            if (controls.controlMode === 'keyboard') {
                speed = Math.sqrt(
                    (keys['w'] || keys['s'] ? 1 : 0) ** 2 + 
                    (keys['a'] || keys['d'] ? 1 : 0) ** 2
                ) * (keys['shift'] ? player.sprintSpeed : player.speed);
            } else {
                speed = Math.sqrt(controls.joystickX ** 2 + controls.joystickY ** 2) * player.speed;
            }
            document.getElementById('speedValue').textContent = speed.toFixed(1);
        }

        function raycaster() {
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.yaw);
            direction.applyAxisAngle(new THREE.Vector3(1, 0, 0), player.pitch);

            raycastHelper.set(player.position, direction);

            let closest = null;
            let closestDist = Infinity;

            for (let entity of entities) {
                if (!entity.alive || entity.type === 'plant') continue; // Exclude plants
                
                // Create a bounding sphere for the entity
                const sphere = new THREE.Sphere(entity.mesh.position, 30);
                
                // Check if ray intersects the sphere
                const target = new THREE.Vector3();
                const intersection = raycastHelper.ray.intersectSphere(sphere, target);
                
                if (intersection) {
                    const dist = player.position.distanceTo(intersection);
                    if (dist < closestDist) {
                        closest = entity;
                        closestDist = dist;
                    }
                }
            }

            return closest;
        }

        function updateTargetInfo() {
            const target = raycaster();
            const targetInfoEl = document.getElementById('targetInfo');

            if (target && target.alive && (target.type === 'deer' || target.type === 'wolf')) {
                const healthPercent = Math.round((target.health / target.maxHealth) * 100);
                const hungerPercent = Math.round(target.foodNeed);
                const thirstPercent = Math.round(target.waterNeed);
                const distance = player.position.distanceTo(target.position).toFixed(1);

                document.getElementById('targetName').textContent = 
                    `${target.type.toUpperCase()}`;
                document.getElementById('targetStats').textContent = 
                    `Health: ${healthPercent}%\nHunger: ${hungerPercent}%\nThirst: ${thirstPercent}%\nDistance: ${distance}m`;
                targetInfoEl.classList.add('visible');

                // Update NN visualizer if enabled
                if (nnVisEnabled && target instanceof Animal) {
                    if (!nnVisualizer) {
                        initNNVisualizer();
                    }
                    if (nnVisualizer && nnVisualizer.ctx) {
                        try {
                            nnVisualizer.draw(target);
                            nnLabel.textContent = `${target.type.toUpperCase()} - Brain Activity`;
                        } catch (e) {
                            console.error('NN Draw error:', e);
                            nnLabel.textContent = 'Error rendering';
                        }
                    }
                }
            } else {
                targetInfoEl.classList.remove('visible');
                if (nnVisEnabled) {
                    nnLabel.textContent = 'No Target';
                    if (nnVisualizer && nnVisualizer.ctx) {
                        nnVisualizer.ctx.clearRect(0, 0, nnVisualizer.w_width, nnVisualizer.w_height);
                    }
                }
            }
        }

        document.getElementById('resetBtn').addEventListener('click', initializeWorld);
        document.getElementById('helpBtn').addEventListener('click', () => {
            document.querySelector('.hud-controls').classList.toggle('show');
        });

        // ============================================================================
        // MAIN LOOP
        // ============================================================================

        let lastTime = Date.now();

        function animate() {
            requestAnimationFrame(animate);

            const now = Date.now();
            const deltaTime = Math.min((now - lastTime) / 1000, 0.1);
            lastTime = now;

            // Update player
            updatePlayer(deltaTime);

            // Update entities with neural networks
            for (let entity of entities) {
                if (entity instanceof Animal && entity.alive) {
                    entity.update(deltaTime, entities, waterLocations);
                } else if (entity instanceof Plant && entity.alive) {
                    entity.update(deltaTime);
                }
            }

            // Handle collisions
            handleCollisions();

            // Remove dead entities
            for (let i = entities.length - 1; i >= 0; i--) {
                if (!entities[i].alive) {
                    entities[i].remove();
                    entities.splice(i, 1);
                }
            }

            // Occasionally spawn new plants
            if (Math.random() < 0.01) {
                entities.push(new Plant([
                    Math.random() * CONFIG.worldWidth,
                    3,
                    Math.random() * CONFIG.worldHeight
                ]));
            }

            // Update target info
            updateTargetInfo();

            // Update stats every second
            ticks++;
            if (ticks % 60 === 0) {
                updateStats();
            }

            // FPS counter
            frameCount++;
            if (now - lastFpsUpdate > 1000) {
                document.getElementById('fpsCounter').textContent = 'FPS: ' + frameCount;
                frameCount = 0;
                lastFpsUpdate = now;
            }

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            if (nnVisualizer) {
                const wrapper = document.getElementById('nnCanvasWrapper');
                const rect = wrapper.getBoundingClientRect();
                nnVisualizer.resize([rect.width, rect.height]);
            }
        });

        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                
                if (nnVisualizer) {
                    const wrapper = document.getElementById('nnCanvasWrapper');
                    const rect = wrapper.getBoundingClientRect();
                    nnVisualizer.resize([rect.width, rect.height]);
                }
            }, 100);
        });

        // Initialize
        initializeWorld();
        animate();
    </script>
</body>
</html>